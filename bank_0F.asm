.include "Constants.inc"
.include "variables.inc"
.feature force_range


.export SoundTestZ
.export OptionsMenu
.export EnterTitleScreen
.export JigsIntro
.export SaveScreen
;.export ReadjustEquipStats
;.export UnadjustEquipStats
.export AssignMapTileDamage_Z
.export WeaponArmorShopStats
.export WeaponArmorSpecialDesc
.export GetWeaponDataPointer
.export GetEquipmentSpell
.export MapPoisonDamage_Z
.export lut_InitUnsramFirstPage
.export SaveScreen_FromMenu
.export LoadSpellForBattle
.export GetEquipPermissions
.export SetCharStats
.export SetPartyStats
.export GetExpToNext
.export GetNekked

.import ADD_ITEM
.import AddGPToParty
.import BattleBGColorDigits
.import BattleBackgroundColor_LUT
.import BattleRNG_L
.import CHRLoad
.import CHRLoadToA
.import CallMusicPlay
.import CallMusicPlay_L
.import CancelNewGame
.import ClearOAM
.import CoordToNTAddr
.import Draw2x2Sprite
.import DrawBox
.import DrawCombatBox_L
.import DrawComplexString
.import DrawCursor
.import DrawPalette
.import DrawPalette_L
.import DrawSimple2x3Sprite
.import GameLoaded
.import GameStart_L
.import LoadBattleSpritesForBank_Z
.import LoadBorderPalette_Blue
.import LoadBridgeSceneGFX_Menu
.import LoadCursorOnly
.import LoadMenuCHRPal
.import LoadMenuCHRPal_Z
.import LoadPtyGenBGCHRAndPalettes
.import LoadShopCHRForBank_Z
.import LongCall
.import MenuCondStall
.import MultiplyXA
.import PlayDoorSFX
.import PlaySFX_Error
.import RandAX
.import ReloadBridgeNT
.import SaveScreenHelper
.import SetPPUAddr_XA
.import Set_Inv_Magic
.import Set_Inv_Weapon
.import ShiftLeft4
.import ShiftLeft6
.import ShiftSpriteHightoLow
.import SwapPRG_L
.import UndrawBattleBlock
.import UpdateJoy
.import WaitForVBlank_L
.import lutClassBatSprPalette
.import lut_InBattleCharPaletteAssign
.import LoadSprite_Bank03




BANK_THIS = $0F

.segment "BANK_0F"

lut_WeaponData:

; Weapon types:
;         first byte |  | second byte
;*------- > Nunchuck |80| Heavy Sword
;-*------ > Staff    |40| Long Sword
;--*----- > Rod      |20| Katana
;---*---- > Axe      |10| Short Sword
;----*--- > Hammer   |08| Dagger
;-----*-- > Bow      |04| 
;------*- > Whip     |02| 
;-------* > Spear    |01| 

;       v ----------------------------- Hit rate
;           v ------------------------- Damage
;               v --------------------- Critical hit rate
;                   v ----------------- Ailment (used to be spell, but that's another list now.)
;                       v-------------- Ailment chance (1-200)
;                           v ------------- Element
;                               v --------- Category effectiveness
;                                   v ----- Graphic
;                                       v - Palette
;                                           v - weapon type 1 (masteries overrides permissions)
;                                                v - weapon type 2 (masteries overrides permissions)
;                                                   v - EQUIP PERMISSIONS
.byte $00,$0C,$0A,$00,$00,$00,$00,$A8,$27, $80, $00, %00100000, %00000000, %01100000, %00000000 ; 00  Wooden nunchucks
.byte $0A,$05,$05,$00,$00,$00,$00,$98,$20, $00, $08, %11010100, %00000000, %11010100, %00000000 ; 01  Small knife
.byte $00,$06,$01,$00,$00,$00,$00,$A0,$27, $40, $00, %10111100, %00000000, %11111100, %00000000 ; 02  Wooden staff
.byte $05,$09,$0A,$00,$00,$00,$00,$90,$20, $00, $10, %11010000, %00000000, %11010000, %00000000 ; 03  Rapier
.byte $00,$09,$01,$00,$00,$00,$00,$94,$27, $08, $00, %10001000, %00000000, %11001000, %00000000 ; 04  Iron hammer
.byte $0A,$0F,$05,$00,$00,$00,$00,$80,$20, $00, $10, %10010000, %00000000, %11010000, %00000000 ; 05  Short sword
.byte $05,$10,$03,$00,$00,$00,$00,$9C,$20, $10, $00, %10000000, %00000000, %11000000, %00000000 ; 06  Hand axe
.byte $0A,$0A,$05,$00,$00,$00,$00,$84,$2B, $00, $40, %11010000, %00000000, %11010000, %00000000 ; 07  Scimitar
.byte $00,$10,$0A,$00,$00,$00,$00,$A8,$20, $80, $00, %00100000, %00000000, %01100000, %00000000 ; 08  Iron nunchucks
.byte $0A,$07,$05,$00,$00,$00,$00,$98,$20, $00, $08, %11010100, %00000000, %11010100, %00000000 ; 09  Large knife
.byte $00,$0E,$01,$10,$1E,$00,$00,$A4,$20, $40, $00, %10100000, %00000000, %11100000, %00000000 ; 0A  Iron Staff      - might cause STUN
.byte $05,$0D,$0A,$00,$00,$00,$00,$90,$20, $00, $10, %11010000, %00000000, %11010000, %00000000 ; 0B  Sabre
.byte $0A,$14,$05,$00,$00,$00,$00,$8C,$20, $00, $40, %10010000, %00000000, %11010000, %00000000 ; 0C  Long sword
.byte $05,$16,$03,$00,$00,$00,$00,$9C,$25, $10, $00, %10000000, %00000000, %11000000, %00000000 ; 0D  Great axe
.byte $0A,$0F,$05,$00,$00,$00,$00,$88,$20, $00, $40, %11010000, %00000000, %11010000, %00000000 ; 0E  Falchion
.byte $0F,$0A,$05,$00,$00,$00,$00,$98,$2C, $00, $08, %11010100, %00000000, %11010100, %00000000 ; 0F  Silver knife
.byte $0F,$17,$05,$00,$00,$00,$00,$8C,$2C, $00, $40, %10010000, %00000000, %11010000, %00000000 ; 10  Silver Sword
.byte $05,$0C,$01,$00,$00,$00,$00,$94,$2C, $08, $00, %10001000, %00000000, %11001000, %00000000 ; 11  Silver Hammer
.byte $0A,$19,$04,$00,$00,$00,$00,$9C,$2C, $10, $00, %10000000, %00000000, %11000000, %00000000 ; 12  Silver Axe
.byte $14,$1A,$05,$00,$00,$10,$88,$88,$26, $00, $40, %10010000, %00000000, %11010000, %00000000 ; 13  Flame sword
.byte $19,$1D,$05,$00,$00,$20,$00,$8C,$21, $00, $40, %10010000, %00000000, %11010000, %00000000 ; 14  Ice sword
.byte $0F,$13,$0A,$00,$00,$00,$02,$90,$2B, $00, $10, %10110000, %00000000, %11010000, %00000000 ; 15  Dragon sword
.byte $14,$15,$05,$00,$00,$00,$04,$80,$22, $00, $80, %10010000, %00000000, %11010000, %00000000 ; 16  Giant sword
.byte $1E,$20,$05,$08,$1E,$00,$08,$8C,$27, $00, $80, %10010000, %00000000, %11010000, %00000000 ; 17  Sun sword       - might cause DARK
.byte $0F,$13,$0A,$00,$00,$00,$20,$90,$25, $00, $10, %10110000, %00000000, %11010000, %00000000 ; 18  Coral sword
.byte $0F,$12,$05,$00,$00,$00,$10,$80,$24, $00, $10, %10010000, %00000000, %11010000, %00000000 ; 19  Were sword
.byte $0F,$12,$05,$40,$1E,$00,$41,$88,$23, $00, $40, %10110000, %00000000, %11010000, %00000000 ; 1A  Rune sword      - might cause MUTE
.byte $00,$0C,$01,$00,$00,$00,$00,$A0,$2A, $20, $00, %10101100, %00000000, %11101100, %00000000 ; 1B  Power staff
.byte $0F,$1C,$03,$08,$2F,$00,$08,$9C,$23, $10, $00, %10000000, %00000000, %11000000, %00000000 ; 1C  Light axe       - casts HARM 2, might cause DARK
.byte $00,$06,$01,$00,$00,$00,$00,$A4,$21, $40, $00, %00001000, %00000000, %01001000, %00000000 ; 1D  Heal staff      - casts HEAL
.byte $0A,$0C,$01,$00,$00,$00,$00,$A4,$25, $20, $00, %00000100, %00000000, %01000100, %00000000 ; 1E  Mage staff      - casts FIRE 2
.byte $23,$1E,$05,$00,$00,$00,$00,$80,$27, $00, $80, %00000000, %00000000, %11010000, %00000000 ; 1F  Defense swrd    - casts SHIELD
.byte $0F,$0F,$01,$00,$00,$00,$00,$A4,$2C, $20, $00, %00000000, %00000000, %00000100, %00000000 ; 20  Wizard staff    - casts CONFUSE
.byte $19,$18,$1E,$00,$00,$00,$00,$88,$21, $00, $40, %00000000, %00000000, %11010000, %00000000 ; 21  Vorpal sword
.byte $23,$16,$05,$00,$00,$00,$00,$98,$2C, $00, $08, %00000000, %00000000, %11010100, %00000000 ; 22  CatClaw
.byte $0F,$12,$01,$00,$00,$00,$00,$94,$24, $08, $00, %00000000, %00000000, %11001000, %00000000 ; 23  Thor Hammer     - casts BOLT 2
.byte $14,$16,$0A,$04,$14,$00,$00,$90,$22, $00, $40, %00000000, %00000000, %11010000, %00000000 ; 24  Bane sword      - casts BANE, might cause POISON
.byte $23,$21,$1E,$00,$00,$00,$00,$98,$27, $00, $20, %00000000, %00000000, %01000000, %00000000 ; 25  Katana
.byte $23,$2D,$05,$00,$00,$FF,$FF,$8C,$28, $00, $80, %00000000, %00000000, %10000000, %00000000 ; 26  Excalibur
.byte $32,$38,$0A,$00,$00,$00,$00,$84,$20, $00, $20, %11111111, %00000000, %11111111, %00000000 ; 27  Masamune
.byte $28,CKD,$0A,$00,$FF,$00,$14,$98,$28, $00, $08, %11010100, %00000000, %11011100, %00000000 ; 28  Chicken Knife
.byte $20,BBD,$05,$00,$00,$00,$0A,$8C,$2A, $00, $40, %11010000, %00000000, %11010000, %00000000 ; 29  Brave Blade
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2A
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2B
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2C
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2D
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2E
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 2F
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 30
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 31
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 32
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 33
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 34
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 35
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 36
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 37
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 38
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 39
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3A
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3B
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3C
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3D
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3E
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 3F
.byte $00,$00,$00,$00,$00,$00,$00,$00,$00, $00, $00, %00000000, %00000000, %00000000, %00000000 ; 40





; Status defense bits:
;*------- > Confusion
;-*------ > Mute
;--*----- > Stun
;---*---- > Sleep
;----*--- > Blindness
;-----*-- > Poison
;------*- > Stone
;-------* > Death

; Elemental defense/weakness bits:
;*------- > Earth
;-*------ > Lightning
;--*----- > Ice
;---*---- > Fire
;----*--- > Deathy stuff  / WATER
;-----*-- > Poisony stuff / WIND
;------*- > Stunny stuff  / HOLY
;-------* > ??            / DARK
;; JIGS - these last 4 are kind of weird? Vanilla FF uses like... status as elements or something.
;; FF Hackster lists them as things like Time, Status, Death...
;; I forget why Constants.inc has them listed as the caps versions shown here.

; Category bits:
;*------- > Regenerative
;-*------ > Magic
;--*----- > Water
;---*---- > Were
;----*--- > Undead
;-----*-- > Giant
;------*- > Dragon
;-------* > Unknown

; Equipment types:
;            first byte  |  | second byte 
;*------- > Heavy Shield |80| Bracelet
;-*------ > Plate Armor  |40| Chain Armor
;--*----- > Plate Helmet |20| Chain Helmet
;---*---- > Plate Gloves |10| Chain gloves
;----*--- > Light Shield |08| Robes
;-----*-- > Scale Armor  |04| Leather Armor
;------*- > Scale Helmet |02| Leather Helmet
;-------* > Scale Gloves |01| Leather Gloves

; Armor Perks:
;*------- > 80 Regenerate
;-*------ > 40 Counter
;--*----- > 20 Reflect
;---*---- > 10 Speed Boost
;----*--- > 08 Absorb HP
;-----*-- > 04 Random Dodge
;------*- > 02 Focus Aim
;-------* > 01 Rage

; Armor Slots:
;  0 = weapon
;  1 = shield
;  2 = helmet
;  3 = body
;  4 = gloves
;  5 = accessory

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Armor data!  [$8140 :: 0x30150]
;;
;;  4 bytes per armor, 40 armors ($A0 bytes total)
;;
;;  byte 0:  Evade penality
;;  byte 1:  Absorb boost
;;  byte 2:  Magic evade boost
;;  byte 3:  Elemental defense
;;  byte 4:  Elemental weakness
;;  byte 5:  Status defense
;;  Spell LUT is seperated

lut_ArmorData:
;      v - Evade penalty - (JIGS - should never be higher than $63 or armor shop descriptions will look off)
;          v - Absorb boost
;              v - Magic Defense Boost
;                   v - Elemental defense
;                              v - Elemental weakness
;                                         v - Status defense
;                                                    v - HP bonus
;                                                        v - Armor Perks
;                                                            v - Armor Slot 
;                                                                v - equipment type 1 (masteries override permissions)
;                                                                    v - equipment type 2 (masteries override permissions)
;                                                                         v- EQUIP PERMISSIONS    
;.byte $02,$01,$00,%00000000, %00000000, %00000000, 00, $00, 3, $00,$00, %00000011, $11111111, %00000011, %11111111 ; Cloth T ;; original
.byte $00,$02,$00, %00000000, %00000000, %00000000, 00, $00, 3, $00,$08, %11111100, $00000000, %11111100, %00000000 ; 00 Cloth T  ;; JIGS - c'mon, that's just mean... At least make it a little useful.
.byte $08,$04,$00, %00000000, %00000000, %00000000, 00, $00, 3, $04,$00, %11110000, $00000000, %11110000, %00000000 ; 01 Wooden armor
.byte $0F,$0F,$00, %00000000, %00000000, %00000000, 00, $00, 3, $00,$40, %10010000, $00000000, %11010000, %00000000 ; 02 Chain armor
.byte $17,$18,$00, %00000000, %00000000, %00000000, 00, $00, 3, $40,$00, %10000000, $00000000, %11000000, %00000000 ; 03 Iron armor
.byte $21,$22,$00, %00000000, %00000000, %00010000, 00, $00, 3, $40,$00, %10000000, $00000000, %10000000, %00000000 ; 04 Steel armor
.byte $08,$12,$00, %00000000, %00000000, %00000000, 00, $00, 3, $04,$00, %10010000, $00000000, %11010000, %00000000 ; 05 Silver armor
.byte $0A,$22,$03, %00100000, %00010000, %00000000, 00, $00, 3, $04,$00, %10000000, $00000000, %11000000, %00000000 ; 06 Flame armor
.byte $0A,$22,$03, %00010000, %00100000, %00000000, 00, $00, 3, $04,$00, %10000000, $00000000, %11000000, %00000000 ; 07 Ice armor
.byte $0A,$2A,$05, %01000000, %00000000, %00000000, 00, $00, 3, $40,$00, %00000000, $00000000, %10000000, %00000000 ; 08 Opal armor
.byte $0A,$2A,$08, %01110000, %00000000, %00000000, 00, $00, 3, $04,$00, %00000000, $00000000, %10000000, %00000000 ; 09 Dragon armor
.byte $01,$04,$00, %00000000, %00000000, %00000000, 10, $00, 5, $00,$80, %11111100, $00000000, %11111100, %00000000 ; 0A Copper Q
.byte $01,$0F,$00, %00000000, %00000000, %00000000, 20, $00, 5, $00,$80, %11111100, $00000000, %11111100, %00000000 ; 0B Silver Q
.byte $01,$18,$00, %00000000, %00000000, %00000000, 30, $00, 5, $00,$80, %11111100, $00000000, %11111100, %00000000 ; 0C Gold Q
.byte $01,$22,$0A, %00000000, %00000000, %00000000, 40, $00, 5, $00,$80, %11111100, $00000000, %11111100, %00000000 ; 0D Opal Q
.byte $02,$18,$0A, %00011000, %00000000, %00011000, 15, $00, 3, $00,$00, %00000000, $00000000, %00001000, %00000000 ; 0E White T        - casts INVIS 2
.byte $02,$18,$0A, %00100100, %00000000, %00100100, 15, $00, 3, $00,$00, %00000000, $00000000, %00000100, %00000000 ; 0F Black T        - casts ICE 2
.byte $00,$02,$00, %00000000, %00000000, %00000000, 00, $00, 1, $08,$00, %10000000, $00000000, %11000000, %00000000 ; 10 Wooden shield
.byte $00,$04,$00, %00000000, %00000000, %00000000, 00, $00, 1, $80,$00, %10000000, $00000000, %11000000, %00000000 ; 11 Iron shield
.byte $00,$08,$00, %00000000, %00000000, %00000000, 00, $00, 1, $08,$00, %10000000, $00000000, %11000000, %00000000 ; 12 Silver shield
.byte $00,$0C,$03, %00100000, %00010000, %00000000, 00, $00, 1, $80,$00, %10000000, $00000000, %11000000, %00000000 ; 13 Flame shield
.byte $00,$0C,$03, %00010000, %00100000, %00000000, 00, $00, 1, $80,$00, %10000000, $00000000, %11000000, %00000000 ; 14 Ice shield
.byte $00,$10,$05, %01000000, %00000000, %00000000, 00, $00, 1, $80,$00, %00000000, $00000000, %10000000, %00000000 ; 15 Opal shield
.byte $00,$10,$0A, %00000100, %00000000, %11000000, 00, $00, 1, $80,$00, %00000000, $00000000, %10000000, %00000000 ; 16 Aegis shield
.byte $00,$02,$00, %00000000, %00000000, %00000000, 00, $00, 1, $08,$00, %11010000, $00000000, %11010000, %00000000 ; 17 Buckler
.byte $02,$08,$0A, %00000000, %00000000, %00000001, 20, $04, 1, $00,$00, %11011100, $00000000, %11011100, %00000000 ; 18 Protect cape
.byte $01,$01,$00, %00000000, %00000000, %00000000, 00, $00, 2, $00,$02, %11111100, $00000000, %11111100, %00000000 ; 19 Cap
.byte $03,$03,$00, %00000000, %00000000, %00000000, 00, $00, 2, $00,$20, %10000000, $00000000, %11000000, %00000000 ; 1A Wooden helm
.byte $05,$05,$00, %00000000, %00000000, %00000000, 00, $00, 2, $20,$00, %10000000, $00000000, %11000000, %00000000 ; 1B Iron helm
.byte $03,$06,$00, %00000000, %00000000, %00000000, 00, $00, 2, $02,$00, %10000000, $00000000, %11000000, %00000000 ; 1C Silver helm
.byte $03,$08,$05, %00000000, %00000000, %00000000, 00, $00, 2, $20,$00, %00000000, $00000000, %10000000, %00000000 ; 1D Opal helm
.byte $03,$06,$00, %00000000, %00000000, %00000000, 00, $80, 2, $20,$00, %00000000, $00000000, %11000000, %00000000 ; 1E Heal helm      - casts HEAL
.byte $01,$01,$10, %00000000, %00000000, %11111111, 10, $00, 2, $00,$00, %11111111, $00000000, %11111111, %00000000 ; 1F Ribbon
.byte $01,$01,$00, %00000000, %00000000, %00000000, 00, $00, 4, $00,$01, %11111100, $00000000, %11111100, %00000000 ; 20 Gloves
.byte $03,$02,$00, %00000000, %00000000, %00000000, 00, $00, 4, $00,$10, %10000000, $00000000, %11000000, %00000000 ; 21 Copper Gauntlet
.byte $05,$04,$00, %00000000, %00000000, %00000000, 00, $00, 4, $10,$00, %10000000, $00000000, %11000000, %00000000 ; 22 Iron Gauntlet
.byte $03,$06,$00, %00000000, %00000000, %00000000, 00, $00, 4, $01,$00, %10000000, $00000000, %11010000, %00000000 ; 23 Silver Gauntlet
.byte $03,$06,$03, %00000000, %00000000, %00010000, 00, $00, 4, $01,$00, %00000000, $00000000, %11010000, %00000000 ; 24 Zeus Gauntlet  - casts BOLT 2
.byte $03,$06,$05, %00000000, %00000000, %00000000, 00, $00, 4, $10,$00, %10000000, $00000000, %11010000, %00000000 ; 25 Power Gauntlet - casts SABER
.byte $03,$08,$05, %00000000, %00000000, %00000000, 00, $00, 4, $10,$00, %00000000, $00000000, %10000000, %00000000 ; 26 Opal Gauntlet
.byte $01,$08,$0A, %00001000, %00000000, %00000001, 20, $20, 4, $00,$00, %11111100, $00000000, %11111100, %00000000 ; 27 Protect Ring
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 28
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 29
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2A
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2B
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2C
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2D
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2E
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 2F
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 30
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 31
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 32
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 33
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 34
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 35
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 36
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 37
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 38
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 39
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3A
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3B
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3C
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3D
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3E
.byte $00,$00,$00, %00000000, %00000000, %00000000, 00, $00, 0, $00,$00, %00000000, $00000000, %00000000, %00000000 ; 3F

lut_EquipmentSpells:                                         
.byte $00     ;00; Wooden nunchucks                          
.byte $00     ;01; Small knife                               
.byte $00     ;02; Wooden staff
.byte $00     ;03; Rapier
.byte $00     ;04; Iron hammer
.byte $00     ;05; Short sword
.byte $00     ;06; Hand axe
.byte $00     ;07; Scimitar
.byte $00     ;08; Iron nunchucks
.byte $00     ;09; Large knife
.byte $00     ;0A; Iron Staff
.byte $00     ;0B; Sabre
.byte $00     ;0C; Long sword
.byte $00     ;0D; Great axe
.byte $00     ;0E; Falchion
.byte $00     ;0F; Silver knife
.byte $00     ;10; Silver Sword
.byte $00     ;11; Silver Hammer
.byte $00     ;12; Silver Axe
.byte $00     ;13; Flame sword
.byte $00     ;14; Ice sword
.byte $00     ;15; Dragon sword
.byte $00     ;16; Giant sword
.byte $00     ;17; Sun sword
.byte $00     ;18; Coral sword
.byte $00     ;19; Were sword
.byte $00     ;1A; Rune sword
.byte $00     ;1B; Power staff
.byte MG_HRM2 ;1C; Light axe       - casts HARM 2
.byte MG_HEAL ;1D; Heal staff      - casts HEAL
.byte MG_FIR2 ;1E; Mage staff      - casts FIRE 2
.byte MG_FOG  ;1F; Defense swrd    - casts SHIELD
.byte MG_CONF ;20; Wizard staff    - casts CONFUSE
.byte $00     ;21; Vorpal sword
.byte $00     ;22; CatClaw
.byte MG_LIT2 ;23; Thor Hammer     - casts BOLT 2
.byte MG_BANE ;24; Bane sword      - casts BANE
.byte $00     ;25; Katana
.byte $00     ;26; Excalibur
.byte $00     ;27; Masamune
.byte $00     ;28; Chicken Knife
.byte $00     ;29; Brave Blade
.byte $00     ;2A;
.byte $00     ;2B;
.byte $00     ;2C;
.byte $00     ;2D;
.byte $00     ;2E;
.byte $00     ;2F;
.byte $00     ;30;
.byte $00     ;31;
.byte $00     ;32;
.byte $00     ;33;
.byte $00     ;34;
.byte $00     ;35;
.byte $00     ;36;
.byte $00     ;37;
.byte $00     ;38;
.byte $00     ;39;
.byte $00     ;3A;
.byte $00     ;3B;
.byte $00     ;3C;
.byte $00     ;3D;
.byte $00     ;3E;
.byte $00     ;3F;

.byte $00     ;40; Cloth T
.byte $00     ;41; Wooden armor
.byte $00     ;42; Chain armor
.byte $00     ;43; Iron armor
.byte $00     ;44; Steel armor
.byte $00     ;45; Silver armor
.byte $00     ;46; Flame armor
.byte $00     ;47; Ice armor
.byte $00     ;48; Opal armor
.byte $00     ;49; Dragon armor
.byte $00     ;4A; Copper Q
.byte $00     ;4B; Silver Q
.byte $00     ;4C; Gold Q
.byte $00     ;4D; Opal Q
.byte MG_INV2 ;4E; White T        - casts INVIS 2
.byte MG_ICE2 ;4F; Black T        - casts ICE 2
.byte $00     ;50; Wooden shield
.byte $00     ;51; Iron shield
.byte $00     ;52; Silver shield
.byte $00     ;53; Flame shield
.byte $00     ;54; Ice shield
.byte $00     ;55; Opal shield
.byte $00     ;56; Aegis shield
.byte $00     ;57; Buckler
.byte $00     ;58; Protect cape
.byte $00     ;59; Cap
.byte $00     ;5A; Wooden helm
.byte $00     ;5B; Iron helm
.byte $00     ;5C; Silver helm
.byte $00     ;5D; Opal helm
.byte MG_HEAL ;5E; Heal helm      - casts HEAL
.byte $00     ;5F; Ribbon
.byte $00     ;60; Gloves
.byte $00     ;61; Copper Gauntlet
.byte $00     ;62; Iron Gauntlet
.byte $00     ;63; Silver Gauntlet
.byte MG_LIT2 ;64; Zeus Gauntlet  - casts BOLT 2
.byte MG_SABR ;65; Power Gauntlet - casts SABER
.byte $00     ;66; Opal Gauntlet
.byte $00     ;67; Protect Ring
.byte $00     ;68; 
.byte $00     ;69; 
.byte $00     ;6A; 
.byte $00     ;6B; 
.byte $00     ;6C; 
.byte $00     ;6D; 
.byte $00     ;6E; 
.byte $00     ;6F; 
.byte $00     ;70; 
.byte $00     ;71; 
.byte $00     ;72; 
.byte $00     ;73; 
.byte $00     ;74; 
.byte $00     ;75; 
.byte $00     ;76; 
.byte $00     ;77; 
.byte $00     ;78; 
.byte $00     ;79; 
.byte $00     ;7A; 
.byte $00     ;7B; 
.byte $00     ;7C; 
.byte $00     ;7D; 
.byte $00     ;7E; 
.byte $00     ;7F; 

;; As you can see here, to set a spell, you can abandon the $ and just use the number of the spell.
;; Reference Bank A for the spell list in normal people numbers, or Constants.inc for hex!

GetEquipmentSpell:
    LDX tmp+10
    LDA lut_EquipmentSpells, X
    STA tmp+10
    RTS
    
LoadSpellForBattle:
;; A = Spell ID
    DEC LongCall_A          ; turn spell ID to 0-based
    LDA LongCall_A          
    LDX #12                 ; multiply by 8 bytes (+4 more for permissions)
    JSR MultiplyXA        
    CLC                   
    ADC #<MagicData       
    STA MagicPointer      
    TXA                   
    ADC #>MagicData       
    STA MagicPointer+1      ; get the pointer to the spell data

    LDY #7                  ; start at the last spell data byte
    LDA InBattle            ; see if its in battle, or in a shop
    BEQ @Permissions_Start  ; if not in battle, then only want to load permissions
    
    ; in battle, no reason to load permissions at all!
   @NormalMagicData: 
    LDA (MagicPointer), Y
    STA SpellData_RAM, Y
    DEY
    BPL @NormalMagicData 
    
    LDA #<SpellData_RAM    ; then set the MagicPointer to the temp spell data in RAM
    STA MagicPointer
    LDA #>SpellData_RAM
    STA MagicPointer+1
    RTS

   @Permissions:             
    LDA (MagicPointer), Y
    STA EquipPermissions-6, Y ; -8 since Y is 8, but want to write to EquipPermissions 0
   @Permissions_Start:        ; Y = 7, so start by incrementing it! 
    INY
    CPY #8+4                  ; 4 bytes of permission data
    BNE @Permissions
    RTS
    
    
MagicData:    
;    
; JIGS - I highly recommend using FFHackster to design your magic, then copy-p    
;        and comment out the stuff below. For weapons and armours, too.    
;    
;; JIGS note - When loading up magic data, about #90 bytes can be saved by cha    
;; A = magic ID    
;; LDX #7    
;; JSR MultiplyXA    
;; ...then deleting the unused byte from all of these.    
       
;      ╒ Hit Rate    
;      |   ╒ Effectivity    
;      |   |   ╒ Element
;      |   |   |   ╒ Target
;      |   |   |   |   ╒ Effect
;      |   |   |   |   |   ╒ Graphic (low bits: 1 = move left, 2 = move up, 0 = don't move sprite)
;      |   |   |   |   |   |   ╒ Palette
;      |   |   |   |   |   |   |   ╒ Message
;      |   |   |   |   |   |   |   |    CLASS PERMISSIONS
;      v   v   v   v   v   v   v   v    v 
.byte $00,$10,$00,$10,$07,$C1,$29,$01, %00011000, %00000000, %10011000, %00000000 ; 00 CURE           ; HP up!
.byte $18,$14,$00,$01,$02,$C9,$21,$00, %00001000, %00000000, %00001000, %00000000 ; 01 HARM           
.byte $00,$08,$00,$10,$09,$B1,$29,$02, %00011000, %00000000, %10011000, %00000000 ; 02 SHIELD         ; Armor up
.byte $00,$50,$00,$04,$10,$B1,$22,$03, %00001000, %00000000, %10011000, %00000000 ; 03 BLINK          ; Easy to dodge
.byte $18,$0A,$10,$02,$01,$D1,$26,$00, %00010100, %00000000, %01010100, %00000000 ; 04 FIRE           
.byte $18,$20,$01,$01,$03,$E8,$2B,$00, %00010100, %00000000, %01010100, %00000000 ; 05 SLEEP          
.byte $40,$14,$00,$02,$0E,$B9,$28,$05, %00010100, %00000000, %01010100, %00000000 ; 06 LOCK           ; Easy to hit
.byte $18,$0A,$40,$02,$01,$C9,$28,$00, %00010100, %00000000, %01010100, %00000000 ; 07 BOLT           
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 08 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 09 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 0F Time 
.byte $00,$08,$00,$10,$08,$E2,$27,$00, %00011000, %00000000, %10011000, %00000000 ; 10 LAMP           
.byte $40,$40,$01,$01,$03,$E8,$2C,$00, %00011000, %00000000, %10011000, %00000000 ; 11 MUTE           
.byte $00,$40,$00,$08,$0A,$B1,$28,$08, %00011000, %00000000, %10011000, %00000000 ; 12 BOLT (Shield)  ; Defend lightning
.byte $00,$28,$00,$10,$10,$B1,$23,$03, %00011000, %00000000, %10011000, %00000000 ; 13 INVISBL        ; Easy to dodge
.byte $18,$14,$20,$02,$01,$D1,$21,$00, %00010100, %00000000, %01010100, %00000000 ; 14 ICE            
.byte $18,$08,$01,$01,$03,$E8,$23,$00, %00010100, %00000000, %01010100, %00000000 ; 15 DARK           
.byte $00,$0E,$00,$10,$0B,$B9,$2B,$0A, %00010100, %00000000, %01010100, %00000000 ; 16 TEMPER         ; Weapons stronger
.byte $40,$00,$01,$01,$04,$E8,$2A,$0B, %00010100, %00000000, %01010100, %00000000 ; 17 SLOW           ; Lost intelligence
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 18 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 19 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 1F Time 
.byte $00,$21,$00,$10,$07,$C1,$2B,$01, %00011000, %00000000, %10011000, %00000000 ; 20 CURE 2         ; HP up!
.byte $18,$28,$00,$01,$02,$C9,$23,$00, %00001000, %00000000, %00001000, %00000000 ; 21 HARM 2         
.byte $00,$10,$00,$08,$0A,$B1,$26,$0C, %00011000, %00000000, %10011000, %00000000 ; 22 FIRE (shield)  ; Defend fire
.byte $03,$20,$00,$08,$15,$C1,$28,BTLMSG_REGENERATING, %00001000, %00000000, %00001000, %00000000 ; 23 REGEN    ;; JIGS - Heal spells temporarily replaced
;.byte $00,$0C,$00,$08,$07,$C0,$28,$00, %00001000, %00000000, %00001000, %00000000 ; 23 HEAL     ;; backup of original spell
.byte $18,$1E,$10,$01,$01,$D1,$27,$00, %00010100, %00000000, %01010100, %00000000 ; 24 FIRE 2 
.byte $40,$10,$01,$02,$03,$E8,$27,$0D, %00010100, %00000000, %01010100, %00000000 ; 25 HOLD            ; Attack halted
.byte $18,$1E,$40,$01,$01,$C9,$27,$00, %00010100, %00000000, %01010100, %00000000 ; 26 BOLT 2          
.byte $40,$14,$00,$01,$0E,$B9,$27,$05, %00010100, %00000000, %01010100, %00000000 ; 27 LOCK 2          ; Easy to hit
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 28 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 29 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 2F Time 
.byte $00,$04,$00,$10,$08,$E2,$2A,$00, %00011000, %00000000, %00011000, %00000000 ; 30 PURE            
.byte $18,$28,$01,$01,$05,$E8,$25,$0F, %00001000, %00000000, %00001000, %00000000 ; 31 FEAR            ; Became terrified
.byte $00,$20,$00,$08,$0A,$B1,$21,$10, %00011000, %00000000, %00011000, %00000000 ; 32 ICE (shield)    ; Defend cold
.byte $00,$40,$00,$10,$08,$E2,$2C,$00, %00001000, %00000000, %00011000, %00000000 ; 33 VOICE           
.byte $40,$20,$00,$02,$03,$E8,$21,$00, %00010100, %00000000, %01010100, %00000000 ; 34 SLEEP 2         
.byte $00,$00,$00,$10,$0C,$B9,$2A,$12, %00010100, %00000000, %01010100, %00000000 ; 35 FAST            ; Quick shot
.byte $40,$80,$01,$01,$03,$E8,$26,$00, %00010100, %00000000, %01010100, %00000000 ; 36 CONFUSE         
.byte $18,$28,$20,$01,$01,$D1,$22,$00, %00010100, %00000000, %01010100, %00000000 ; 37 ICE 2           
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 38 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 39 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 3F Time 
.byte $00,$42,$00,$10,$07,$C1,$2C,$01, %00011000, %00000000, %00011000, %00000000 ; 40 CURE 3          ; HP up!
.byte $00,$01,$00,$10,$06,$E2,$21,$4F, %00001000, %00000000, %00011000, %00000000 ; 41 LIFE     ; JIGS- will now cure death ; Revived from the brink!
.byte $18,$3C,$00,$01,$02,$C9,$25,$00, %00001000, %00000000, %00001000, %00000000 ; 42 HARM 3 
.byte $04,$40,$00,$08,$15,$C1,$27,BTLMSG_REGENERATING, %00001000, %00000000, %00001000, %00000000 ; 43 REGEN 2
;.byte $00,$18,$00,$08,$07,$C0,$27,$00, %00001000, %00000000, %00001000, %00000000 ; 43 HEAL 2
.byte $18,$32,$10,$01,$01,$D1,$25,$00, %00010100, %00000000, %00010100, %00000000 ;FIR3 ; 44 FIRE 3    
.byte $28,$01,$02,$01,$03,$E8,$22,$4D, %00000100, %00000000, %00010100, %00000000 ;BANE ; 45 BANE             ; Poison smoke
.byte $FF,$00,$00,$08,$00,$00,$00,$4A, %00000000, %00000000, %00010100, %00000000 ;WARP ; 46 WARP             ; Ineffective now
.byte $40,$00,$00,$02,$04,$E8,$29,$0B, %00010100, %00000000, %00010100, %00000000 ;SLO2 ; 47 SLOW 2           ; Lost intelligence
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 48 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 49 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 4F Time 
.byte $00,$02,$00,$10,$14,$E2,$20,$00, %00001000, %00000000, %00001000, %00000000 ;SOFT ; 50 SOFT             ; JIGS - will now cure stone
.byte $FF,$00,$00,$08,$00,$00,$00,$4A, %00000000, %00000000, %00011000, %00000000 ;EXIT ; 51 EXIT             ; Ineffective now
.byte $00,$0C,$00,$08,$09,$B1,$2A,$02, %00001000, %00000000, %00011000, %00000000 ;FOG2 ; 52 SHIELD2          ; Armor up
.byte $00,$28,$00,$08,$10,$B1,$24,$03, %00001000, %00000000, %00011000, %00000000 ;INV2 ; 53 INVIS 2          ; Easy to dodge
.byte $18,$3C,$40,$01,$01,$C9,$22,$00, %00000100, %00000000, %00010100, %00000000 ;LIT3 ; 54 BOLT 3           
.byte $18,$01,$08,$02,$03,$D9,$20,$15, %00000100, %00000000, %00000100, %00000000 ;RUB ; 55 RUB              ; Erased
.byte $28,$01,$80,$01,$03,$B9,$26,$16, %00000100, %00000000, %00000100, %00000000 ;QAKE ; 56 QUAKE            ; Fell into crack
.byte $00,$10,$01,$02,$12,$E8,$28,$00, %00000100, %00000000, %00000100, %00000000 ;STUN ; 57 STUN   
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 58 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 59 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ;???? ; 5F Time 
.byte $00,$00,$00,$10,$0F,$C1,$21,$18, %00000000, %00000000, %00001000, %00000000 ;CUR4 ; 60 CURE 4           ; HP max! 
.byte $30,$50,$00,$01,$02,$C9,$2C,$00, %00000000, %00000000, %00001000, %00000000 ;HRM4 ; 61 HARM 4           
.byte $00,$89,$00,$08,$0A,$B1,$25,$19, %00001000, %00000000, %00011000, %00000000 ;ARUB ; 62 RUB (shield)     ; Defend magic ;; JIGS should be "defend death?"
.byte $05,$60,$00,$08,$15,$C1,$25,BTLMSG_REGENERATING, %00001000, %00000000, %00001000, %00000000 ; 63 REGEN 3
;.byte $30,$30,$00,$08,$07,$C0,$25,$00, %00001000, %00000000, %00001000, %00000000 ; 63 HEAL 3
.byte $18,$46,$20,$01,$01,$D1,$2B,$00, %00000100, %00000000, %00010100, %00000000 ; 64 ICE 3  
.byte $40,$02,$02,$02,$03,$C9,$20,$00, %00000000, %00000000, %00000100, %00000000 ; 65 BREAK  
.byte $0F,$10,$00,$04,$0D,$B9,$20,$00, %00000000, %00000000, %00000100, %00000000 ; 66 SABER             ; Weapon became enchanted (JIGS - added $0F to Hit Rate)
.byte $00,$08,$01,$02,$12,$E8,$24,$00, %00000100, %00000000, %00000100, %00000000 ; 67 BLIND             
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 68 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 69 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 6F Time 
.byte $00,$01,$00,$10,$13,$D9,$21,$00, %00000000, %00000000, %00001000, %00000000 ; 70 LIFE 2 (Cures death now!) ; Revived from the brink!
.byte $6B,$50,$00,$01,$01,$C9,$24,$00, %00000000, %00000000, %00001000, %00000000 ; 71 HOLY              
.byte $00,$FF,$00,$10,$0A,$B1,$20,$00, %00000000, %00000000, %00001000, %00000000 ; 72 WALL              ; Defend all
.byte $6B,$00,$00,$02,$11,$B9,$20,$00, %00000000, %00000000, %00001000, %00000000 ; 73 DISPEL            ; Defenseless
.byte $6B,$64,$00,$01,$01,$D1,$28,$00, %00000000, %00000000, %00000100, %00000000 ; 74 FLARE             
.byte $30,$10,$04,$01,$03,$E8,$20,$00, %00000000, %00000000, %00000100, %00000000 ; 75 STOP              ; Time stopped
.byte $20,$01,$04,$01,$03,$D9,$2B,$00, %00000000, %00000000, %00000100, %00000000 ; 76 BANISH            ; Exile to 4th dimension
.byte $00,$01,$08,$02,$12,$D9,$28,$00, %00000000, %00000000, %00000100, %00000000 ; 77 DOOM              ; Erased
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 78 Green 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 79 Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7A Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7B Green
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7C Time 
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7D Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7E Time
.byte $00,$00,$00,$00,$00,$00,$00,$00, %00000000, %00000000, %00000000, %00000000 ; 7F Time 
; $400 bytes ^ 

;      ╒ Hit Rate
;      |   ╒ Effectivity
;      |   |   ╒ Element
;      |   |   |   ╒ Target
;      |   |   |   |   ╒ Effect
;      |   |   |   |   |   ╒ Graphic
;      |   |   |   |   |   |   ╒ Palette
;      |   |   |   |   |   |   |   ╒ Message
;      v   v   v   v   v   v   v   v  
.byte $00,$0C,$00,$08,$07,$C1,$28,$01 ; 80 HEAL                   
.byte $00,$18,$00,$08,$07,$C1,$27,$01 ; 81 HEAL 2                 
.byte $30,$30,$00,$08,$07,$C1,$25,$01 ; 82 HEAL 3                 
.byte $00,$08,$00,$10,$FC,$C1,$20,$00 ; 83 Pray - Cure Ailment    
.byte $00,$05,$00,$04,$18,$B1,$2C,BTLMSG_DEFENDALL ; 84 Reflect   
.byte $00,$00,$00,$00,$00,$00,$00,BTLMSG_DEFENDALL ; 85 Reflect 2 
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 86 ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 87 ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 88 ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 89 ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 8A ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 8B ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 8C ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 8D ????                   
.byte $00,$00,$00,$00,$00,$00,$00,$00 ; 8E ????                   
.byte $00,$00,$00,$04,$17,$00,$00,BTLMSG_QUICKSHOT ; 8F Counter   
;; $80 bytes
;; removed heal and pure data

;; Enemy attacks
.byte $20,$18,$20,$01,$01,$00,$20,$00 ; 00 FROST      ; 90   
.byte $20,$0C,$10,$01,$01,$00,$20,$00 ; 01 HEAT       ; 91   
.byte $05,$02,$02,$02,$03,$00,$20,$00 ; 02 GLANCE     ; 92   
.byte $00,$10,$01,$02,$03,$00,$20,$00 ; 03 GAZE       ; 93   
.byte $18,$08,$01,$01,$03,$00,$20,$00 ; 04 FLASH      ; 94   
.byte $20,$07,$10,$01,$01,$00,$20,$00 ; 05 SCORCH     ; 95   
.byte $10,$01,$80,$01,$03,$00,$20,$16 ; 06 CRACK      ; 96   ; Fell into crack
.byte $00,$01,$08,$02,$03,$00,$20,$15 ; 07 SQUINT     ; 97   ; Erased
.byte $18,$11,$00,$02,$01,$00,$20,$00 ; 08 STARE      ; 98   ; 
.byte $10,$01,$04,$02,$03,$00,$20,$1F ; 09 GLARE      ; 99   ; Exile to 4th dimension
.byte $20,$32,$20,$01,$01,$00,$20,$00 ; 0A BLIZZARD   ; 9A   ; 
.byte $20,$40,$10,$01,$01,$00,$20,$00 ; 0B BLAZE      ; 9B   ; 
.byte $20,$60,$10,$01,$01,$00,$20,$00 ; 0C INFERNO    ; 9C   ; 
.byte $20,$18,$10,$01,$01,$00,$20,$00 ; 0D CREMATE    ; 9D   ; 
.byte $05,$02,$02,$01,$03,$00,$20,$4D ; 0E POISON     ; 9E   ; Poison smoke - JIGS - doesn't make sense, never did. Poison turns to stone? Sure it stops time now, why not.
.byte $00,$10,$00,$01,$03,$00,$20,$00 ; 0F TRANCE     ; 9F   ; 
.byte $20,$44,$02,$01,$01,$00,$20,$00 ; 10 POISON     ; A0   ; 
.byte $20,$4C,$40,$01,$01,$00,$20,$00 ; 11 THUNDER    ; A1   ; 
.byte $00,$01,$08,$01,$03,$00,$20,$15 ; 12 TOXIC      ; A2   ; Erased
.byte $18,$08,$01,$02,$03,$00,$20,$00 ; 13 SNORTING   ; A3   
.byte $30,$50,$00,$01,$01,$00,$20,$00 ; 14 NUCLEAR    ; A4   
.byte $18,$08,$01,$01,$03,$00,$20,$00 ; 15 INK        ; A5   
.byte $00,$04,$02,$01,$03,$00,$20,$00 ; 16 STINGER    ; A6   
.byte $20,$10,$01,$02,$03,$00,$20,$00 ; 17 DAZZLE     ; A7   
.byte $20,$40,$00,$01,$01,$00,$20,$00 ; 18 SWIRL      ; A8   
.byte $20,$40,$00,$01,$01,$00,$20,$00 ; 19 TORNADO    ; A9   
; $D0 bytes
;      ╒ Hit Rate
;      |   ╒ Effectivity
;      |   |   ╒ Element
;      |   |   |   ╒ Target
;      |   |   |   |   ╒ Effect
;      |   |   |   |   |   ╒ Graphic
;      |   |   |   |   |   |   ╒ Palette
;      |   |   |   |   |   |   |   ╒ Message
;      v   v   v   v   v   v   v   v  
.byte $10,$05,$00,$02,$01,$00,$20,$00 ; 1A IMP PUNCH  ; AA
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 1B            ; AB
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 1C            ; AC
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 1D            ; AD
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 1E            ; AE
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 1F            ; AF
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 20            ; B0
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 21            ; B1
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 22            ; B2
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 23            ; B3
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 24            ; B4
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 25            ; B5
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 26            ; B6
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 27            ; B7
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 28            ; B8
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 29            ; B9
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2A            ; BA
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2B            ; BB
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2C            ; BC
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2D            ; BD
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2E            ; BE
.byte $00,$00,$00,$00,$00,$00,$20,$00 ; 2F            ; BF
    










    
GetEquipPermissions:
    LDA LongCall_A
    LDX shop_type
    BEQ GetWeaponDataPointer
    CPX #1
    BEQ GetPointerToArmorData
    JMP LoadSpellForBattle

GetWeaponDataPointer:
   ; SEC
   ; SBC #$01               ; subtract 1 from the equip ID (equipment is 1 based -- 0 is an empty slot)
    TAY                    ; save A
    DEY                    ; NOW subtract 1 from the Equip ID!
    TXA                    ; then push X to stack
    PHA
    TYA                    ; restore A
    LDX #15
    JSR MultiplyXA
    CLC
    ADC #<lut_WeaponData
    STA tmp                ; put in tmp as low byte of our pointer
    TXA
    ADC #>lut_WeaponData   ; add high byte of our pointer
    JMP EquipmentByteLoop

GetPointerToArmorData:
    SEC
    SBC #ARMORSTART+1
    TAY                    ; save A
    TXA                    ; then push X to stack
    PHA
    TYA                    ; restore A
    LDX #15
    JSR MultiplyXA
    CLC
    ADC #<lut_ArmorData    ; add low byte of our pointer
    STA tmp                ; put in tmp as low byte of our pointer
    TXA
    ADC #>lut_ArmorData    ; add high byte of our pointer

EquipmentByteLoop:
    STA tmp+1              ; fill tmp+1 to complete our pointer
    LDY #0
   @Loop: 
    LDA (tmp), Y
    STA EquipStats_RAM, Y  ; fill temp RAM with equipment info
    INY
    CPY #15-6              ; < # of bytes to copy over before doing permissions
    BNE @Loop
    
SetEquipPermissions:    
    LDA InBattle           ; don't bother doing this in battle, it will overwrite other pointers
    BNE :+

    LDX #0
   @Loop: 
    LDA (tmp), Y           ; last 5 bytes go here
    STA EquipPermissions, X
    INY
    INX
    CPX #6
    BNE @Loop    
    LDY #ARMOR_SLOT
    LDA EquipStats_RAM, Y  ; save ArmorSlot (or weapon palette; but that's not needed)
    STA ArmorSlot
  : LDY #0                 ; and set Y to 0 for later   
    PLA
    TAX                    ; then restore X
    RTS
    




;; this also sets hit multiplier for the party!
;; this is pretty big, but it replaces the old equipment adjustment routines



GetNekked:
    JSR Set_Inv_Weapon

    LDX submenu_targ
    LDY #$8
   @Loop: 
    LDA ch_righthand, X
    BEQ :+               ; skip if empty
    PHA                  ; backup item in slot
    LDA #0
    STA ch_righthand, X  ; replace with 0
    PLA
    STY tmp+7            ; backup X, Y
    STX tmp+8
    SEC                  ; set item ID to 0-based
    SBC #1
    JSR ADD_ITEM         ; add item back into inventory
    LDX tmp+8
    LDY tmp+7            ; restore X, Y
  : INX                  ; INX to check next slot
    DEY                  ; Decrement loop counter
    BNE @Loop
    RTS



SetCharStats:
    JSR ClearPartyStats
    STA tmp+5             ; set to 0
    JSR SetPartyStats_Loop
    LDX submenu_targ
    LDA DualWieldStats
    BEQ @RightHand
    
   @LeftHand: 
    LDA btl_charweaponcritrate+4, X
    STA MenuStats+5
    LDA btl_charhitrate+4, X
    STA MenuStats+1
    LDA btl_chardamage+4, X
    STA MenuStats
    BNE @Defense     ; should always branch; damage should never be 0, unlike critrate
    
   @RightHand: 
    LDA btl_chardamage, X
    STA MenuStats
    LDA btl_charhitrate, X
    STA MenuStats+1
    LDA btl_charweaponcritrate, X
    STA MenuStats+5
    
   @Defense: 
    LDA btl_chardefense, X
    STA MenuStats+2
    LDA btl_charevasion, X
    STA MenuStats+3
    LDA btl_charmagdefense, X
    STA MenuStats+4
    RTS

ClearPartyStats:
    LDX #$74
    LDA #0
   @Clear: 
    STA btlstats_mainstats-1, X
    DEX
    BNE @Clear
    RTS

SetPartyStats:
    JSR ClearPartyStats

    ;; this clears all stats in RAM

    LDA #3
    STA tmp+5             ; loop counter
    STA submenu_targ
    
SetPartyStats_Loop: 
    LDA submenu_targ
    LSR A
    ROR A
    ROR A
    TAX
    STA char_index
    
    LDA #0
    STA tmp+2              ; save as left/right hand flag

    LDY submenu_targ
    LDA ch_evasion, X      
    STA btl_charevasion, Y
    LDA ch_magicdefense, X
    STA btl_charmagdefense, Y

    ;; and set up other stats for armor later, from main ch_stats to btl_char stats
    
    LDA ch_righthand, X
   @WeaponLoop: 
    BNE @WeaponEquipped

    LDY #9
   @ClearWeaponRAM:        ; clear weapon RAM since they're unequipped
    STA EquipStats_RAM, Y
    DEY
    BPL @ClearWeaponRAM

    LDA ch_attackperks, X
    AND #UNARMED
    BNE @SetFists
    
    LDY #WEAPON_PAL         ; they have no weapon so
    LDA #$20                ; set the palette to white/grey
    STA EquipStats_RAM, Y
    BNE @DoWeaponStats      ; and calculate other stats based off not having a weapon
    
   @SetFists: 
    LDY #WEAPON_DAMAGE      
    LDA ch_level, X         ; if unequipped, get current experience level
    CLC                     ; add 1 (levels are stored 0 based in RAM -- ie '0' is really level 1)
    ADC #1                  ; multiply by 2
    ASL A                   ; and set dmg.  Unequipped BB's dmg = (level*2)
    STA EquipStats_RAM, Y   
    LDY #WEAPON_CRIT
    STA EquipStats_RAM, Y   ; so is crit rate
   
    LDA #$AC
    LDY #WEAPON_GFX
    STA EquipStats_RAM, Y   ; fist sprite
    LDA ch_sprite, X
    TAY
    LDA lut_InBattleCharPaletteAssign, Y
    AND #$3F
    ORA #$80                ; convert byte to fancy palette control code
    LDY #WEAPON_PAL
    STA EquipStats_RAM, Y   ; with special palettes for each sprite
    LDA #02                 ; hit multiplier is 2 for unarmed proficiency
    STA tmp+3
    BNE @DoWeaponStats
    
   @WeaponEquipped: 
    CMP #ARMORSTART          ; make sure its not a shield
    BCC :+
      JSR @AdjustArmor
      JMP @CheckLeft         ; set up the rest of armor stuff
    
  : JSR GetWeaponDataPointer ; Y = 0, X is restored, EquipStats_RAM holds weapon data
    LDA #01
    STA tmp+3                ; they have a weapon, so hit multiplier is 1
    STA tmp+4                ; tmp+4 = 1 for leaving number of hits alone later
    
   @DoWeaponStats: 
    LDA ch_attackperks, X
    AND #UNARMED
    BEQ @NormalWeapon
    
    LDA #0
    STA tmp+4                ; set tmp+4 to 0 to double numhits later
    LDY #WEAPON_DAMAGE
    LDA ch_strength, X
    LSR A
    CLC
    ADC EquipStats_RAM, Y    
    STA EquipStats_RAM, Y    ; save strength / 2 + weapon damage as weapon damage
   
   @NormalWeapon:
    LDY #WEAPON_HIT
    LDA ch_hitrate, X        ; base stat
    CLC
    ADC EquipStats_RAM, Y    ; + weapon accuracy
    BCC :+
        LDA #$FF             ; cap at 255
  : PHA                      ; push hit rate
    
    INY            
    LDA EquipStats_RAM, Y    ; weapon damage
    CMP #CHICKENKNIFE_DAMAGE
    BNE :+                   ; if its the chicken knife
        LDA battlesrun       ; use amount of battles run from as damage
        JMP @WeaponDamage
 : CMP #BRAVEBLADE_DAMAGE       
   BNE @WeaponDamage         ; if its the brave blade
        LDA battleswon       ; use amount of battles won as damage
    
   @WeaponDamage: 
    CLC 
    ADC ch_damage, X         ; + base stat
    BCC :+
        LDA #$FF             ; cap at 255
  : PHA                      ; push damage
  
    LDX submenu_targ
    LDA tmp+3
    STA btl_charhitmult, X   ; save hit multiplier (changed by FAST/SLOW magic)
    
    LDA tmp+2                ; see if it was the left hand or right hand
    BEQ :+
    
    INX                      ; if left hand, increase char_index to +4
    INX
    INX
    INX
    DEC tmp+2
    DEC tmp+2                ; set tmp+2 to $FF
    
  : INY
    LDA EquipStats_RAM, Y    ; weapon crit
    STA btl_charweaponcritrate, X
    INY
    LDA EquipStats_RAM, Y    ; weapon ailment
    STA btl_charweaponailment, X
    INY
    LDA EquipStats_RAM, Y    ; weapon ailment proc chance
    STA btl_charweaponailproc, X
    INY
    LDA EquipStats_RAM, Y    ; weapon element
    STA btl_charweaponelement, X
    INY
    LDA EquipStats_RAM, Y    ; weapon category
    STA btl_charweaponcategory, X
    INY
    LDA EquipStats_RAM, Y    ; weapon sprite
    STA btl_charweaponsprite, X
    INY
    LDA EquipStats_RAM, Y    ; weapon palette
    STA btl_charweaponpal, X

    PLA
    STA btl_chardamage, X  
    
    PLA 
    STA btl_charhitrate, X 
    JSR CalcNumHits           ; number of hits for this weapon
  
  @CheckLeft:
    LDA tmp+2
    BMI @DualWielding         ; if its $FF (dual-wielding confirmed)
    BNE @Armor                ; if its 1 (checked left hand item already)

    INC tmp+2                 ; set tmp+2 to 1 to do next hand    
    LDX char_index
    LDA ch_lefthand, X
    BEQ @TwoHanded_Check      ; Nothing equipped, so see if they're two-handed
    JMP @WeaponLoop        
   
   @TwoHanded_Check: 
    LDA ch_attackperks, X
    AND #TWOHANDED
    BEQ @Armor               ; they're not two-handed, so do armor        

    LDA ch_strength, X
    LSR A
    STA tmp+2                ; strength/2 
    LSR A
    CLC 
    ADC tmp+2                ; + strength/4
    LDY #WEAPON_DAMAGE
    ADC EquipStats_RAM, Y    ; + weapon damage

    LDX submenu_targ
    STA btl_chardamage, X  
    BNE @Armor
    
  @DualWielding:
    ;; Hit% = (Weapon Accuracy + Character's Hit%) * 3/4
    ;; so 15 would be 11.25 
  
    ;; JIGS - thanks to the guys on the NESDev Discord for helping with this!
  
    TXA
    TAY
   @DualWieldLoop: 
    LDA btl_charhitrate, Y
    LDX #$C0                 ; "abridgewater: $c0, or 192, is 3/4 of $100 or 256."
    JSR MultiplyXA 
    TXA
    STA btl_charhitrate, Y   ; save high byte of the multiplication
    JSR CalcNumHits
    DEY
    DEY
    DEY
    DEY                      ; go back to the first weapon's value
    INC tmp+2                ; inc back to $0, then to $1 to break out of the loop
    BEQ @DualWieldLoop

  @Armor:
    LDX char_index  
    LDA ch_head, X
    BEQ :+
    JSR @AdjustArmor  ; head

  : LDA ch_body, X
    BEQ :+
    JSR @AdjustArmor  ; body

  : LDA ch_hands, X
    BEQ :+
    JSR @AdjustArmor  ; hands

  : LDA ch_accessory, X 
    BEQ @SpecialArmorStats
    JSR @AdjustArmor
    
    ;; and if an Unarmed mastery character has 0 defense, use their level as their defense
    
   @SpecialArmorStats:
    LDA ch_attackperks, X
    AND #UNARMED
    BEQ @NextCharacter
    
    LDY submenu_targ
    LDA btl_chardefense, Y
    BNE @NextCharacter
    
    LDA ch_level, X
    CLC
    ADC #1
    STA btl_chardefense, Y

   @NextCharacter:
    LDA ch_intelligence, X
    STA btl_charintelligence, Y
    LDA ch_speed, X
    STA btl_charspeed, Y   
   
    ;; finally, do sprite attributes
    LDY ch_sprite, X
    LDA lut_InBattleCharPaletteAssign, Y
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    ORA #$20 ; $20 is set on all so sprites are behind the background. This is so when the screen shakes and some characters are turned to BG tiles while stoned, the 3d effect is mostly preserved.
    LDX submenu_targ
    STA btl_charattrib, X
   
    DEC tmp+5
    BMI @Exit
    DEC submenu_targ
    JMP SetPartyStats_Loop
    
   @Exit: 
    RTS

   @AdjustArmor:            ; A = armor_id
    JSR GetPointerToArmorData

    LDX submenu_targ
    ;LDY #ARMOR_EVADE      ; Y = 0 from GetPointerToArmorData
    LDA btl_charevasion, X
    SEC
    SBC EquipStats_RAM, Y  ; subtract armor evade penalty
    BCS :+                 
        LDA #0             ; cap at 0 evasion
  : STA btl_charevasion, X ; and write it back
    
    INY                    ; inc source index
    LDA btl_chardefense, X ; get absorb
    CLC
    ADC EquipStats_RAM, Y  ; add absorb bonus
    BCC :+
      LDA #$FF             ; cap at 255
  : STA btl_chardefense, X ; and write back

    INY
    LDA btl_charmagdefense, X
    CLC
    ADC EquipStats_RAM, Y
    BCC :+
      LDA #$FF             ; cap at 255
  : STA btl_charmagdefense, X

    INY                          ; inc source index
    LDA btl_charelementresist, X ; get elemental resistence
    ORA EquipStats_RAM, Y        ; combine this armor's elemental resistence
    STA btl_charelementresist, X ; and write back

    INY
    LDA btl_charelementweak, X   ; get elemental weakness
    ORA EquipStats_RAM, Y        ; combine this armor's elemental weakness
    STA btl_charelementweak, X   ; and write back

    INY
    LDA btl_charstatusresist, X
    ORA EquipStats_RAM, Y
    STA btl_charstatusresist, X
    
    LDX char_index               ; get HP bonus from armor
    INY
    LDA EquipStats_RAM, Y
    CLC
    ADC ch_basehp, X             ; add with base HP (max without armor)
    STA ch_maxhp, X              ; store as new max HP
    LDA ch_basehp+1, X           ; and do the same with the high byte, including carry
    STA ch_maxhp+1, X    
    CMP #HP_MAX_HIGH             ; see if high byte of new max is over the limit
    BEQ @CheckLow                ; if its exact, check the low byte
    BCC :+                       ; otherwise, exit
    
   @CheckLow:
    LDA ch_maxhp, X              
    CMP #HP_MAX_LOW
    BEQ :+                       ; if the low byte is exact, exit
    BCC :+                       ; or if its clear, exit
        LDA #HP_MAX_HIGH         ; otherwise, cap max HP
        STA ch_maxhp+1, X
        LDA #HP_MAX_LOW
        STA ch_maxhp, X    
  : INY
    LDA btl_chararmorperks
    ORA EquipStats_RAM, Y
    STA btl_chararmorperks
    RTS

CalcNumHits:
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    CLC
    ADC #1
    LDX tmp+4
    BNE :+
     ASL A                    ; double number of hits if they're unarmed with proficiency!    
  : LDX submenu_targ
    STA btl_charnumhits, X    ; number of hits for this weapon
    RTS



WeaponArmorShopStats:
    LDA #$FF
    LDX #12
  : STA bigstr_buf-1, X
    DEX
    BNE :-

    STX bigstr_buf+11 ; null-terminate main string

    LDA #$01
    STA bigstr_buf+3 ; put line break in
    STA bigstr_buf+7

    LDA #14
    STA dest_x
    LDA #20
    STA dest_y

    LDA shop_curitem
    CMP #ARMORSTART+1
    BCS @Armor

   @Weapon:
    TAX
    JSR GetWeaponDataPointer   ; Y = 0, also preserves X

    LDA (tmp), Y ; Hit Rate
    STA bigstr_buf+16
    INY
    LDA (tmp), Y ; Damage
    CMP #CHICKENKNIFE_DAMAGE
    BNE :+
        LDA battlesrun
        BNE @SaveWeaponDamage

  : CMP #BRAVEBLADE_DAMAGE
    BNE @SaveWeaponDamage

    LDA battleswon
    JMP @SaveWeaponDamage
    
   @Armor:
   ; CLC
   ; ADC #1 ; the following JSR subtracts +1 too many, but needs to stay doing that for other routines
    JSR GetPointerToArmorData

    LDA (tmp), Y ; Evade penalty for armor | Hit rate for weapon
    STA bigstr_buf+16
    INY
    LDA (tmp), Y ; Absorb for armor        | Damage for weapon
    
   @SaveWeaponDamage:    
    STA bigstr_buf+12
    INY
    LDA (tmp), Y ; Magic Defense for armor | Critical for weapon
    STA bigstr_buf+20
    RTS


;; Now, if it were possible to show these numbers for only 1 character... and palette #2 was set to make white text green
;; then if Hit Rate was higher than their current stat, you'd want to set the high nybble of $23EB to 7, and the high nybble of $23EC to D
;; and if Damage was higher than their current stat, you'd want to set the low nybble of $23EB to 7, and the low nybble of $23EC to D
;; and if Critical hit was higher, then set the low nybble of $23F3 to 7 and the low nybble of $23F4 to D
;; and this would highlight those stats in green...












M_EquipDescBox_Weapon:
.byte $8A,$61,$34,$B1,$B7,$E4,$FE,$01     ; Ailment:
.byte $8E,$45,$34,$B1,$B7,$E4,$FE,$01     ; Element:
.byte $9C,$B3,$A8,$4E,$E4,$FF,$FF,$FE     ; Spell:__

M_EquipDescBox_Armor:
.byte $99,$4D,$53,$A6,$B7,$E4,$FE,$01     ; Protect:
.byte $9B,$2C,$30,$B7,$E4,$FE,$FF,$01     ; Resist:
.byte $9C,$B3,$A8,$4E,$E4,$FF,$FF,$FE     ; Spell:__

SillyWeaponArmorSpecialDesc_LUT:
    .word M_EquipDescBox_Weapon
    .word M_EquipDescBox_Armor

WeaponArmorSpecialDesc:
    LDA #23
    STA dest_y
    LDA #03
    STA dest_x

    LDX ItemToEquip      ; 1-based
    CPX #ARMORSTART+1
    BCS @Armor

   @Weapon:
    LDX #0
    BEQ :+

   @Armor:
    LDX #2
  : LDA SillyWeaponArmorSpecialDesc_LUT, X
    STA text_ptr
    LDA SillyWeaponArmorSpecialDesc_LUT+1, X   ; load pointer from table, store to text_ptr  (source pointer for DrawComplexString)
    STA text_ptr+1

    LDY #0
    LDX #0
   @Loop:
    LDA (text_ptr), Y
    CMP #$FE
    BEQ @FillSpaces
    STA str_buf+$80, X
    INX
   @Resume:
    INY
    CPY #$18
    BNE @Loop
    BEQ @SortOutBytes

   @FillSpaces:
    STY tmp
    LDY #18
    LDA #$FF
  : STA str_buf+$80, X
    INX
    DEY
    BNE :-
    LDY tmp
    JMP @Resume

   @SortOutBytes:
    LDA ItemToEquip
    CMP #ARMORSTART+1
    BCS @ArmorBytes

   @WeaponBytes:
    JSR GetWeaponDataPointer
    JMP :+

   @ArmorBytes:
    JSR GetPointerToArmorData
  : LDY #3
    LDA (tmp), Y ; Ailment to inflict (weapon) / Element resisted (armor)
    STA tmp+11
    INY
    INY
    LDA (tmp), Y ; Element to attack with (weapon) / Status defended against (armor)
    STA tmp+12

    LDA tmp+10        ; 0-based item ID
    CMP #ARMORSTART
    BCC :+

   @FixArmorBytes:   ; swap the Elemental resist and Status defense bytes for display purposes
    LDX tmp+12
    LDY tmp+11
    STX tmp+11
    STY tmp+12
  
  : JSR GetEquipmentSpell
    BEQ @NoSpell
    
    STA str_buf+$BB   ; spell ID
    LDA #$06
    STA str_buf+$BA   ; control code for magic name, before spell ID
    LDA #$0A
    STA str_buf+$BD   ; amount of spaces after spell
    BNE @FinishUp

   @NoSpell:
    LDA #$02
    STA str_buf+$BD   ; amount of spaces after "no spell"    
    STA str_buf+$BA   ; also the control code for items and common strings
    LDA #$8D
    STA str_buf+$BB   ; followed by the string ID for "no spell"

   @FinishUp:
    LDA #$09
    STA str_buf+$BC   ; next byte is # of spaces
    LDA #0
    STA str_buf+$BE   ; terminate the string properly
    STA joy_start     ; and zero this for the next loop of the screen!
    STA tmp+13
    LDA #1
    STA menustall     ; and set this to draw with the screen on

    ;; str_buf+$80 is 26 tiles wide each row, with +1 for the line breaks
    ;; three rows for 81 total. Spell names are 7 tiles.
    ;; all spaces must be preserved to overwrite common equipment stats!
    ;; But with the spell name decompressed, that's 7 spaces too many...

    ;; visually, it should look like this, if there is a spell:
    ;; Ailment:_*_*_*_*_*_*_*_*__ 01
    ;; Element:_*_*_*_*_*_*_*_*__ 01
    ;; Spell:___XXXXXXX__________ 00
    ;; it may look messier in RAM.
    ;; Spell: FF FF FF 02 XX 09 0A 00

    ;; now to convert the other two stats into tiles!

    LDA tmp+11 ; start with ailment
    LDX #$07   ; how far into the string to print the icons
    LDY #$F1   ; tile for fancy tiny X to indicate nothing in that slot

   @UnrollStatByte:
    LSR A
    BCC :+
      LDY #$E9 ; death
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$ED ; stone
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$EB ; poison
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$EC ; darkness
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$75 ; sleep
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$71 ; stun
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$76 ; mute
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$70 ; confusion
  : JSR @PrintIcon

  ;; and then the element icon
    LDA tmp+12
    LDX #$20

  @UnrollElementByte:
    LSR A
    BCC :+
      LDY #$70 ; status element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$71 ; stun element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$EB ; poison element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$E9 ; death element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$72 ; fire element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$73 ; ice element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$74 ; lightning element
  : JSR @PrintIcon
    LSR A
    BCC :+
      LDY #$ED ; earth element
  : JSR @PrintIcon

    LDA #<(str_buf+$80)
    STA text_ptr
    LDA #>(str_buf+$80)
    STA text_ptr+1
    RTS

   ;; string should be ready to go; jump back and print it!

   @PrintIcon:
    PHA
    TYA
    STA str_buf+$80, X
    INX
    INX ; add spaces between icons
    LDY #$F1
    PLA
    RTS































;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Exp to advance to the next level  [$9000 :: 0x2D010]

lut_ExpToAdvance:
  .FARADDR     40 ; level 2 
  .FARADDR    196 ; level 3 
  .FARADDR    547 ; level 4 
  .FARADDR   1171 ; level 5 
  .FARADDR   2146 ; level 6 
  .FARADDR   3550 ; level 7 
  .FARADDR   5461 ; level 8 
  .FARADDR   7957 ; level 9 
  .FARADDR  11116 ; level 10
  .FARADDR  15016 ; level 11
  .FARADDR  19735 ; level 12
  .FARADDR  25351 ; level 13
  .FARADDR  31942 ; level 14
  .FARADDR  39586 ; level 15
  .FARADDR  48361 ; level 16
  .FARADDR  58345 ; level 17
  .FARADDR  69617 ; level 18
  .FARADDR  82253 ; level 19
  .FARADDR  96332 ; level 20
  .FARADDR 111932 ; level 21
  .FARADDR 129131 ; level 22
  .FARADDR 148008 ; level 23
  .FARADDR 168639 ; level 24
  .FARADDR 191103 ; level 25
  .FARADDR 215479 ; level 26
  .FARADDR 241843 ; level 27
  .FARADDR 270275 ; level 28
  .FARADDR 300851 ; level 29
  .FARADDR 333651 ; level 30
  .FARADDR 366450 ; level 31
  .FARADDR 399250 ; level 32
  .FARADDR 432049 ; level 33
  .FARADDR 464849 ; level 34
  .FARADDR 497648 ; level 35
  .FARADDR 530448 ; level 36
  .FARADDR 563247 ; level 37
  .FARADDR 596047 ; level 38
  .FARADDR 628846 ; level 39
  .FARADDR 661646 ; level 40
  .FARADDR 694445 ; level 41
  .FARADDR 727245 ; level 42
  .FARADDR 760044 ; level 43
  .FARADDR 792844 ; level 44
  .FARADDR 825643 ; level 45
  .FARADDR 858443 ; level 46
  .FARADDR 891242 ; level 47
  .FARADDR 924042 ; level 48
  .FARADDR 956841 ; level 49
  .FARADDR 989641 ; level 50

  ;; in hex, it would look like this:
  ;.byte $00,$00,$28 ; level 2
  ;.byte #00,$00,$C4 ; level 3
  ;.byte #00,$02,$23 ; level 4
  ;.byte #00,$04,$93 ; level 5
  ;.byte #00,$08,$62 ; level 6
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Level up data!  [$9094 :: 0x2D0A4]
;;
;;  Data consists of 2 bytes per level.
;;  49 levels per class
;;   6 classes (promoted classes share their unpromoted data)
;;
;;  Byte 0:  bit 5:  set if level up is "strong" (extra 20-24 HP bonus)
;;           bit 4:  set for guaranteed Str increase
;;           bit 3:  set for guaranteed Agil increase
;;           bit 2:  set for guaranteed Int increase
;;           bit 1:  set for guaranteed Vit increase
;;           bit 0:  set for guaranteed Luck increase
;;
;;  Byte 1:  MP up.  Each bit corresponds to a level of spell.
;;            Ex:  bit 0 means you'll get a level 1 charge
;;                 bit 7 means you'll get a level 8 charge

data_LevelUpData_Raw:

;; ...still, I'd rather use FFHackster and just cut/paste the data into the .bin...

;; JIGS - alternate explanation of the bits: 1 means do the boost, 0 means nothing!
;; 7, 6, 5,  4,   3,    2,   1,   0    ::             7, 6, 5, 4, 3, 2, 1, 0
;; x, x, HP, Str, Agil, Int, Vit, Luck ;; Magic Level 8, 7, 6, 5, 4, 3, 2, 1 

data_LevelUpData_Class1: ;; Class 1 - Fighter
.byte %00111010, %00000000 ; Level 1 
.byte %00111011, %00000000 ; Level 2 
.byte %00111101, %00000000 ; Level 3 
.byte %00111010, %00000000 ; Level 4 
.byte %00111011, %00000000 ; Level 5 
.byte %00111101, %00000000 ; Level 6 
.byte %00111010, %00000000 ; Level 7 
.byte %00111011, %00000000 ; Level 8 
.byte %00111101, %00000000 ; Level 9 
.byte %00111010, %00000000 ; Level 10
.byte %00011011, %00000000 ; Level 11
.byte %00111101, %00000000 ; Level 12
.byte %00111010, %00000000 ; Level 13
.byte %00011011, %00000000 ; Level 14
.byte %00111101, %00000000 ; Level 15
.byte %00111010, %00000000 ; Level 16
.byte %00011011, %00000000 ; Level 17
.byte %00111101, %00000000 ; Level 18
.byte %00111010, %00000000 ; Level 19
.byte %00010011, %00000000 ; Level 20
.byte %00111101, %00000000 ; Level 21
.byte %00111010, %00000000 ; Level 22
.byte %00010011, %00000000 ; Level 23
.byte %00011101, %00000000 ; Level 24
.byte %00111010, %00000000 ; Level 25
.byte %00010011, %00000000 ; Level 26
.byte %00011101, %00000000 ; Level 27
.byte %00111010, %00000000 ; Level 28
.byte %00010011, %00000000 ; Level 29
.byte %00011101, %00000000 ; Level 30
.byte %00110010, %00000000 ; Level 31
.byte %00011001, %00000000 ; Level 32
.byte %00010110, %00000000 ; Level 33
.byte %00111001, %00000000 ; Level 34
.byte %00010010, %00000000 ; Level 35
.byte %00011101, %00000000 ; Level 36
.byte %00110010, %00000000 ; Level 37
.byte %00011001, %00000000 ; Level 38
.byte %00010110, %00000000 ; Level 39
.byte %00111000, %00000000 ; Level 40
.byte %00010000, %00000000 ; Level 41
.byte %00011100, %00000000 ; Level 42
.byte %00110000, %00000000 ; Level 43
.byte %00011000, %00000000 ; Level 44
.byte %00010000, %00000000 ; Level 45
.byte %00111000, %00000000 ; Level 46
.byte %00010000, %00000000 ; Level 47
.byte %00011000, %00000000 ; Level 48
.byte %00110000, %00000000 ; Level 49

;; 27 HP
;; 49 Strength
;; 35 Agililty
;; 14 Intelligence
;; 25 Vitality
;; 24 Speed

;; Class 2 - Thief
data_LevelUpData_Class2:
.byte %00111001, %00000000 ; Level 1 
.byte %00110111, %00000000 ; Level 2 
.byte %00111001, %00000000 ; Level 3 
.byte %00110101, %00000000 ; Level 4 
.byte %00011011, %00000000 ; Level 5 
.byte %00110101, %00000000 ; Level 6 
.byte %00011001, %00000000 ; Level 7 
.byte %00110011, %00000000 ; Level 8 
.byte %00011101, %00000000 ; Level 9 
.byte %00100001, %00000000 ; Level 10
.byte %00011011, %00000000 ; Level 11
.byte %00110101, %00000000 ; Level 12
.byte %00001001, %00000000 ; Level 13
.byte %00110011, %00000000 ; Level 14
.byte %00011101, %00000000 ; Level 15
.byte %00001001, %00000000 ; Level 16
.byte %00110011, %00000000 ; Level 17
.byte %00011101, %00000000 ; Level 18
.byte %00001001, %00000000 ; Level 19
.byte %00110011, %00000000 ; Level 20
.byte %00011101, %00000000 ; Level 21
.byte %00001001, %00000000 ; Level 22
.byte %00110011, %00000000 ; Level 23
.byte %00011101, %00000000 ; Level 24
.byte %00001001, %00000000 ; Level 25
.byte %00110011, %00000000 ; Level 26
.byte %00011101, %00000000 ; Level 27
.byte %00001001, %00000000 ; Level 28
.byte %00100011, %00000000 ; Level 29
.byte %00011101, %00000000 ; Level 30
.byte %00001001, %00000000 ; Level 31
.byte %00111011, %00000000 ; Level 32
.byte %00011101, %00000000 ; Level 33
.byte %00001001, %00000000 ; Level 34
.byte %00011011, %00000000 ; Level 35
.byte %00111101, %00000000 ; Level 36
.byte %00001001, %00000000 ; Level 37
.byte %00011011, %00000000 ; Level 38
.byte %00011101, %00000000 ; Level 39
.byte %00101001, %00000000 ; Level 40
.byte %00010011, %00000000 ; Level 41
.byte %00001101, %00000000 ; Level 42
.byte %00010001, %00000000 ; Level 43
.byte %00001011, %00000000 ; Level 44
.byte %00110101, %00000000 ; Level 45
.byte %00001001, %00000000 ; Level 46
.byte %00010011, %00000000 ; Level 47
.byte %00001101, %00000000 ; Level 48
.byte %00010001, %00000000 ; Level 49

;; 18 HP
;; 33 Strength
;; 32 Agililty
;; 17 Intelligence
;; 16 Vitality
;; 49 Speed

;; Class 3 - Black Belt
data_LevelUpData_Class3:
.byte %00101011, %00000000 ; Level 1 
.byte %00010111, %00000000 ; Level 2 
.byte %00101010, %00000000 ; Level 3 
.byte %00010111, %00000000 ; Level 4 
.byte %00001011, %00000000 ; Level 5 
.byte %00110110, %00000000 ; Level 6 
.byte %00001011, %00000000 ; Level 7 
.byte %00010111, %00000000 ; Level 8 
.byte %00101010, %00000000 ; Level 9 
.byte %00010111, %00000000 ; Level 10
.byte %00001011, %00000000 ; Level 11
.byte %00110110, %00000000 ; Level 12
.byte %00001011, %00000000 ; Level 13
.byte %00010111, %00000000 ; Level 14
.byte %00101010, %00000000 ; Level 15
.byte %00110111, %00000000 ; Level 16
.byte %00001011, %00000000 ; Level 17
.byte %00110110, %00000000 ; Level 18
.byte %00001011, %00000000 ; Level 19
.byte %00010111, %00000000 ; Level 20
.byte %00101010, %00000000 ; Level 21
.byte %00010111, %00000000 ; Level 22
.byte %00001011, %00000000 ; Level 23
.byte %00110110, %00000000 ; Level 24
.byte %00001011, %00000000 ; Level 25
.byte %00010111, %00000000 ; Level 26
.byte %00101010, %00000000 ; Level 27
.byte %00010111, %00000000 ; Level 28
.byte %00001011, %00000000 ; Level 29
.byte %00110110, %00000000 ; Level 30
.byte %00101011, %00000000 ; Level 31
.byte %00010111, %00000000 ; Level 32
.byte %00101010, %00000000 ; Level 33
.byte %00010111, %00000000 ; Level 34
.byte %00001011, %00000000 ; Level 35
.byte %00110110, %00000000 ; Level 36
.byte %00001011, %00000000 ; Level 37
.byte %00010111, %00000000 ; Level 38
.byte %00101010, %00000000 ; Level 39
.byte %00010111, %00000000 ; Level 40
.byte %00001011, %00000000 ; Level 41
.byte %00110110, %00000000 ; Level 42
.byte %00001010, %00000000 ; Level 43
.byte %00010111, %00000000 ; Level 44
.byte %00101010, %00000000 ; Level 45
.byte %00110110, %00000000 ; Level 46
.byte %00001011, %00000000 ; Level 47
.byte %00110110, %00000000 ; Level 48
.byte %00001010, %00000000 ; Level 49

;; 20 HP
;; 24 Strength
;; 25 Agililty
;; 24 Intelligence
;; 49 Vitality
;; 30 Speed

;;Class 4 - Red Mage
data_LevelUpData_Class4:
.byte %00110011, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110011, %00000001 ; Level 3 
.byte %00001110, %00000010 ; Level 4 
.byte %00110011, %00000100 ; Level 5 
.byte %00001100, %00000101 ; Level 6 
.byte %00110011, %00000010 ; Level 7 
.byte %00101100, %00000100 ; Level 8 
.byte %00110001, %00001001 ; Level 9 
.byte %00000110, %00001000 ; Level 10
.byte %00111001, %00000100 ; Level 11
.byte %00000111, %00001010 ; Level 12
.byte %00110000, %00000001 ; Level 13
.byte %00001111, %00010000 ; Level 14
.byte %00110001, %00011100 ; Level 15
.byte %00100110, %00000010 ; Level 16
.byte %00011000, %00010000 ; Level 17
.byte %00000111, %00001000 ; Level 18
.byte %00010001, %00100100 ; Level 19
.byte %00001110, %00110001 ; Level 20
.byte %00010000, %00000001 ; Level 21
.byte %00000111, %00100000 ; Level 22
.byte %00011001, %00001010 ; Level 23
.byte %00000100, %00010000 ; Level 24
.byte %00010010, %01100000 ; Level 25
.byte %00101101, %01000100 ; Level 26
.byte %00010001, %00000010 ; Level 27
.byte %00000110, %01100000 ; Level 28
.byte %00011000, %00011000 ; Level 29
.byte %00000101, %10000000 ; Level 30
.byte %00010011, %11000100 ; Level 31
.byte %00001100, %00100000 ; Level 32
.byte %00010000, %10000000 ; Level 33
.byte %00000111, %01010000 ; Level 34
.byte %00011001, %10000000 ; Level 35
.byte %00100100, %00001000 ; Level 36
.byte %00010010, %01000000 ; Level 37
.byte %00001101, %10000000 ; Level 38
.byte %00010001, %00100000 ; Level 39
.byte %00000110, %00000010 ; Level 40
.byte %00011000, %00010000 ; Level 41
.byte %00000101, %10000000 ; Level 42
.byte %00010011, %01000000 ; Level 43
.byte %00001100, %00000100 ; Level 44
.byte %00010000, %00100000 ; Level 45
.byte %00100111, %10000000 ; Level 46
.byte %00011001, %00001000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00010010, %00010000 ; Level 49

;; 13 HP
;; 25 Strength
;; 17 Agililty
;; 24 Intelligence
;; 22 Vitality
;; 25 Speed
 
;;Class 5 - White Mage
data_LevelUpData_Class5:
.byte %00111101, %00000011 ; Level 1 
.byte %00011110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00001110, %00000110 ; Level 4 
.byte %00100101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00101101, %00001100 ; Level 7 
.byte %00000110, %00001010 ; Level 8 
.byte %00110101, %00000001 ; Level 9 
.byte %00001110, %00001100 ; Level 10
.byte %00100101, %00010000 ; Level 11
.byte %00010110, %00010010 ; Level 12
.byte %00101101, %00001001 ; Level 13
.byte %00000110, %00010100 ; Level 14
.byte %00010101, %00100000 ; Level 15
.byte %00101110, %00100010 ; Level 16
.byte %00000101, %00011000 ; Level 17
.byte %00010110, %00100001 ; Level 18
.byte %00101101, %01000100 ; Level 19
.byte %00000110, %01000000 ; Level 20
.byte %00010100, %00110000 ; Level 21
.byte %00001101, %01001000 ; Level 22
.byte %00100110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00001101, %11000000 ; Level 25
.byte %00000110, %00010100 ; Level 26
.byte %00110100, %10000010 ; Level 27
.byte %00001101, %01001000 ; Level 28
.byte %00000110, %10100000 ; Level 29
.byte %00010000, %00000100 ; Level 30
.byte %00101001, %00010000 ; Level 31
.byte %00000010, %10000000 ; Level 32
.byte %00010000, %01000000 ; Level 33
.byte %00001001, %00001000 ; Level 34
.byte %00000010, %00100000 ; Level 35
.byte %00110000, %10000000 ; Level 36
.byte %00001001, %00000010 ; Level 37
.byte %00000010, %01000000 ; Level 38
.byte %00010000, %00010000 ; Level 39
.byte %00001001, %10000000 ; Level 40
.byte %00100010, %00100000 ; Level 41
.byte %00010000, %00000100 ; Level 42
.byte %00001001, %01000000 ; Level 43
.byte %00000010, %10000000 ; Level 44
.byte %00010000, %00001000 ; Level 45
.byte %00101001, %00010000 ; Level 46
.byte %00000010, %00100000 ; Level 47
.byte %00010000, %01000000 ; Level 48
.byte %00001001, %10000000 ; Level 49

;; 15 HP
;; 18 Strength
;; 18 Agililty
;; 29 Intelligence
;; 19 Vitality
;; 20 Speed

;;Class 6 - Black Mage
data_LevelUpData_Class6:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49


data_LevelUpData_Class7:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class8:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

;; 12 HP
;; 13 Strength
;; 13 Agililty
;; 49 Intelligence
;; 14 Vitality
;; 14 Speed

;; Class 9 - Knight  
data_LevelUpData_Class9:
.byte %00111010, %00000000 ; Level 1 
.byte %00111011, %00000000 ; Level 2 
.byte %00111101, %00000000 ; Level 3 
.byte %00111010, %00000000 ; Level 4 
.byte %00111011, %00000000 ; Level 5 
.byte %00111101, %00000000 ; Level 6 
.byte %00111010, %00000000 ; Level 7 
.byte %00111011, %00000000 ; Level 8 
.byte %00111101, %00000000 ; Level 9 
.byte %00111010, %00000000 ; Level 10
.byte %00011011, %00000000 ; Level 11
.byte %00111101, %00000000 ; Level 12
.byte %00111010, %00000000 ; Level 13
.byte %00011011, %00000111 ; Level 14
.byte %00111101, %00000000 ; Level 15
.byte %00111010, %00000111 ; Level 16
.byte %00011011, %00000000 ; Level 17
.byte %00111101, %00000111 ; Level 18
.byte %00111010, %00000000 ; Level 19
.byte %00010011, %00000111 ; Level 20
.byte %00111101, %00000000 ; Level 21
.byte %00111010, %00000111 ; Level 22
.byte %00010011, %00000000 ; Level 23
.byte %00011101, %00000111 ; Level 24
.byte %00111010, %00000000 ; Level 25
.byte %00010011, %00000111 ; Level 26
.byte %00011101, %00000000 ; Level 27
.byte %00111010, %00000111 ; Level 28
.byte %00010011, %00000000 ; Level 29
.byte %00011101, %00000111 ; Level 30
.byte %00110010, %00000000 ; Level 31
.byte %00011001, %00000111 ; Level 32
.byte %00010110, %00000000 ; Level 33
.byte %00111001, %00000111 ; Level 34
.byte %00010010, %00000000 ; Level 35
.byte %00011101, %00000111 ; Level 36
.byte %00110010, %00000000 ; Level 37
.byte %00011001, %00000111 ; Level 38
.byte %00010110, %00000000 ; Level 39
.byte %00111000, %00000111 ; Level 40
.byte %00010000, %00000000 ; Level 41
.byte %00011100, %00000111 ; Level 42
.byte %00110000, %00000000 ; Level 43
.byte %00011000, %00000111 ; Level 44
.byte %00010000, %00000000 ; Level 45
.byte %00111000, %00000111 ; Level 46
.byte %00010000, %00000000 ; Level 47
.byte %00011000, %00000111 ; Level 48
.byte %00110000, %00000000 ; Level 49

;; Class 8 - Ninja
data_LevelUpData_Class10:
.byte %00111001, %00000000 ; Level 1 
.byte %00110111, %00000000 ; Level 2 
.byte %00111001, %00000000 ; Level 3 
.byte %00110101, %00000000 ; Level 4 
.byte %00011011, %00000000 ; Level 5 
.byte %00110101, %00000000 ; Level 6 
.byte %00011001, %00000000 ; Level 7 
.byte %00110011, %00000000 ; Level 8 
.byte %00011101, %00000000 ; Level 9 
.byte %00100001, %00000000 ; Level 10
.byte %00011011, %00000000 ; Level 11
.byte %00110101, %00000000 ; Level 12
.byte %00001001, %00000000 ; Level 13
.byte %00110011, %00001111 ; Level 14
.byte %00011101, %00000000 ; Level 15
.byte %00001001, %00001111 ; Level 16
.byte %00110011, %00000000 ; Level 17
.byte %00011101, %00001111 ; Level 18
.byte %00001001, %00000000 ; Level 19
.byte %00110011, %00001111 ; Level 20
.byte %00011101, %00000000 ; Level 21
.byte %00001001, %00001111 ; Level 22
.byte %00110011, %00000000 ; Level 23
.byte %00011101, %00001111 ; Level 24
.byte %00001001, %00000000 ; Level 25
.byte %00110011, %00001111 ; Level 26
.byte %00011101, %00000000 ; Level 27
.byte %00001001, %00001111 ; Level 28
.byte %00100011, %00000000 ; Level 29
.byte %00011101, %00001111 ; Level 30
.byte %00001001, %00000000 ; Level 31
.byte %00111011, %00001111 ; Level 32
.byte %00011101, %00000000 ; Level 33
.byte %00001001, %00001111 ; Level 34
.byte %00011011, %00000000 ; Level 35
.byte %00111101, %00001111 ; Level 36
.byte %00001001, %00000000 ; Level 37
.byte %00011011, %00001111 ; Level 38
.byte %00011101, %00000000 ; Level 39
.byte %00101001, %00001111 ; Level 40
.byte %00010011, %00000000 ; Level 41
.byte %00001101, %00001111 ; Level 42
.byte %00010001, %00000000 ; Level 43
.byte %00001011, %00001111 ; Level 44
.byte %00110101, %00000000 ; Level 45
.byte %00001001, %00001111 ; Level 46
.byte %00010011, %00000000 ; Level 47
.byte %00001101, %00001111 ; Level 48
.byte %00010001, %00000000 ; Level 49

;; Class 9 - Master
data_LevelUpData_Class11:
.byte %00101011, %00000000 ; Level 1 
.byte %00010111, %00000000 ; Level 2 
.byte %00101010, %00000000 ; Level 3 
.byte %00010111, %00000000 ; Level 4 
.byte %00001011, %00000000 ; Level 5 
.byte %00110110, %00000000 ; Level 6 
.byte %00001011, %00000000 ; Level 7 
.byte %00010111, %00000000 ; Level 8 
.byte %00101010, %00000000 ; Level 9 
.byte %00010111, %00000000 ; Level 10
.byte %00001011, %00000000 ; Level 11
.byte %00110110, %00000000 ; Level 12
.byte %00001011, %00000000 ; Level 13
.byte %00010111, %00000000 ; Level 14
.byte %00101010, %00000000 ; Level 15
.byte %00110111, %00000000 ; Level 16
.byte %00001011, %00000000 ; Level 17
.byte %00110110, %00000000 ; Level 18
.byte %00001011, %00000000 ; Level 19
.byte %00010111, %00000000 ; Level 20
.byte %00101010, %00000000 ; Level 21
.byte %00010111, %00000000 ; Level 22
.byte %00001011, %00000000 ; Level 23
.byte %00110110, %00000000 ; Level 24
.byte %00001011, %00000000 ; Level 25
.byte %00010111, %00000000 ; Level 26
.byte %00101010, %00000000 ; Level 27
.byte %00010111, %00000000 ; Level 28
.byte %00001011, %00000000 ; Level 29
.byte %00110110, %00000000 ; Level 30
.byte %00101011, %00000000 ; Level 31
.byte %00010111, %00000000 ; Level 32
.byte %00101010, %00000000 ; Level 33
.byte %00010111, %00000000 ; Level 34
.byte %00001011, %00000000 ; Level 35
.byte %00110110, %00000000 ; Level 36
.byte %00001011, %00000000 ; Level 37
.byte %00010111, %00000000 ; Level 38
.byte %00101010, %00000000 ; Level 39
.byte %00010111, %00000000 ; Level 40
.byte %00001011, %00000000 ; Level 41
.byte %00110110, %00000000 ; Level 42
.byte %00001010, %00000000 ; Level 43
.byte %00010111, %00000000 ; Level 44
.byte %00101010, %00000000 ; Level 45
.byte %00110110, %00000000 ; Level 46
.byte %00001011, %00000000 ; Level 47
.byte %00110110, %00000000 ; Level 48
.byte %00001010, %00000000 ; Level 49

;;Class 10 - Red Wizard 
data_LevelUpData_Class12:
.byte %00110011, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110011, %00000001 ; Level 3 
.byte %00001110, %00000010 ; Level 4 
.byte %00110011, %00000100 ; Level 5 
.byte %00001100, %00000101 ; Level 6 
.byte %00110011, %00000010 ; Level 7 
.byte %00101100, %00000100 ; Level 8 
.byte %00110001, %00001001 ; Level 9 
.byte %00000110, %00001000 ; Level 10
.byte %00111001, %00000100 ; Level 11
.byte %00000111, %00001010 ; Level 12
.byte %00110000, %00000001 ; Level 13
.byte %00001111, %00010000 ; Level 14
.byte %00110001, %00011100 ; Level 15
.byte %00100110, %00000010 ; Level 16
.byte %00011000, %00010000 ; Level 17
.byte %00000111, %00001000 ; Level 18
.byte %00010001, %00100100 ; Level 19
.byte %00001110, %00110001 ; Level 20
.byte %00010000, %00000001 ; Level 21
.byte %00000111, %00100000 ; Level 22
.byte %00011001, %00001010 ; Level 23
.byte %00000100, %00010000 ; Level 24
.byte %00010010, %01100000 ; Level 25
.byte %00101101, %01000100 ; Level 26
.byte %00010001, %00000010 ; Level 27
.byte %00000110, %01100000 ; Level 28
.byte %00011000, %00011000 ; Level 29
.byte %00000101, %10000000 ; Level 30
.byte %00010011, %11000100 ; Level 31
.byte %00001100, %00100000 ; Level 32
.byte %00010000, %10000000 ; Level 33
.byte %00000111, %01010000 ; Level 34
.byte %00011001, %10000000 ; Level 35
.byte %00100100, %00001000 ; Level 36
.byte %00010010, %01000000 ; Level 37
.byte %00001101, %10000000 ; Level 38
.byte %00010001, %00100000 ; Level 39
.byte %00000110, %00000010 ; Level 40
.byte %00011000, %00010000 ; Level 41
.byte %00000101, %10000000 ; Level 42
.byte %00010011, %01000000 ; Level 43
.byte %00001100, %00000100 ; Level 44
.byte %00010000, %00100000 ; Level 45
.byte %00100111, %10000000 ; Level 46
.byte %00011001, %00001000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00010010, %00010000 ; Level 49
 
;;Class 11 - White Wizard
data_LevelUpData_Class13:
.byte %00111101, %00000011 ; Level 1 
.byte %00011110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00001110, %00000110 ; Level 4 
.byte %00100101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00101101, %00001100 ; Level 7 
.byte %00000110, %00001010 ; Level 8 
.byte %00110101, %00000001 ; Level 9 
.byte %00001110, %00001100 ; Level 10
.byte %00100101, %00010000 ; Level 11
.byte %00010110, %00010010 ; Level 12
.byte %00101101, %00001001 ; Level 13
.byte %00000110, %00010100 ; Level 14
.byte %00010101, %00100000 ; Level 15
.byte %00101110, %00100010 ; Level 16
.byte %00000101, %00011000 ; Level 17
.byte %00010110, %00100001 ; Level 18
.byte %00101101, %01000100 ; Level 19
.byte %00000110, %01000000 ; Level 20
.byte %00010100, %00110000 ; Level 21
.byte %00001101, %01001000 ; Level 22
.byte %00100110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00001101, %11000000 ; Level 25
.byte %00000110, %00010100 ; Level 26
.byte %00110100, %10000010 ; Level 27
.byte %00001101, %01001000 ; Level 28
.byte %00000110, %10100000 ; Level 29
.byte %00010000, %00000100 ; Level 30
.byte %00101001, %00010000 ; Level 31
.byte %00000010, %10000000 ; Level 32
.byte %00010000, %01000000 ; Level 33
.byte %00001001, %00001000 ; Level 34
.byte %00000010, %00100000 ; Level 35
.byte %00110000, %10000000 ; Level 36
.byte %00001001, %00000010 ; Level 37
.byte %00000010, %01000000 ; Level 38
.byte %00010000, %00010000 ; Level 39
.byte %00001001, %10000000 ; Level 40
.byte %00100010, %00100000 ; Level 41
.byte %00010000, %00000100 ; Level 42
.byte %00001001, %01000000 ; Level 43
.byte %00000010, %10000000 ; Level 44
.byte %00010000, %00001000 ; Level 45
.byte %00101001, %00010000 ; Level 46
.byte %00000010, %00100000 ; Level 47
.byte %00010000, %01000000 ; Level 48
.byte %00001001, %10000000 ; Level 49

;;Class 12 - Black Wizard
data_LevelUpData_Class14:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49
   
   
data_LevelUpData_Class15:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class16:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class17:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class18:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class19:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class20:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class21:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class22:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class23:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class24:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class25:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class26:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class27:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class28:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class29:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class30:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class31:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49

data_LevelUpData_Class32:
.byte %00100100, %00000011 ; Level 1 
.byte %00001110, %00000010 ; Level 2 
.byte %00110101, %00000001 ; Level 3 
.byte %00000110, %00000110 ; Level 4 
.byte %00101101, %00000100 ; Level 5 
.byte %00010110, %00000001 ; Level 6 
.byte %00100101, %00001100 ; Level 7 
.byte %00001110, %00001010 ; Level 8 
.byte %00010101, %00000001 ; Level 9 
.byte %00100100, %00001100 ; Level 10
.byte %00001110, %00010000 ; Level 11
.byte %00010100, %00010010 ; Level 12
.byte %00100101, %00001001 ; Level 13
.byte %00001100, %00010100 ; Level 14
.byte %00010110, %00100000 ; Level 15
.byte %00000100, %00100010 ; Level 16
.byte %00101101, %00011000 ; Level 17
.byte %00010100, %00100001 ; Level 18
.byte %00000110, %01000100 ; Level 19
.byte %00001100, %01000000 ; Level 20
.byte %00110101, %00110000 ; Level 21
.byte %00000100, %01001000 ; Level 22
.byte %00001110, %00000011 ; Level 23
.byte %00010100, %10100000 ; Level 24
.byte %00100101, %11000000 ; Level 25
.byte %00001100, %00010100 ; Level 26
.byte %00010110, %10000010 ; Level 27
.byte %00000100, %01001000 ; Level 28
.byte %00101101, %10100000 ; Level 29
.byte %00010100, %00000100 ; Level 30
.byte %00000110, %00010000 ; Level 31
.byte %00001100, %10000000 ; Level 32
.byte %00010101, %01000000 ; Level 33
.byte %00100100, %00001000 ; Level 34
.byte %00001110, %00100000 ; Level 35
.byte %00010100, %10000000 ; Level 36
.byte %00000101, %00000010 ; Level 37
.byte %00001100, %01000000 ; Level 38
.byte %00010110, %00010000 ; Level 39
.byte %00100100, %10000000 ; Level 40
.byte %00000101, %00100000 ; Level 41
.byte %00000100, %00000100 ; Level 42
.byte %00000110, %01000000 ; Level 43
.byte %00000100, %10000000 ; Level 44
.byte %00000101, %00001000 ; Level 45
.byte %00000100, %00010000 ; Level 46
.byte %00000110, %00100000 ; Level 47
.byte %00000100, %01000000 ; Level 48
.byte %00000101, %10000000 ; Level 49


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  data_MaxRewardPlusOne  [$99A3 :: 0x2D9B3]
;;    note that this is actually 1 higher than the max for some reason...
;;  Also note this name is slightly misleading.  It's not the maximum reward, it's the
;;  maximum value you can have AFTER being rewarded.  Effectively it is the GP/XP cap.
    
data_MaxRewardPlusOne:
  .FARADDR 1000000          ; 'FARADDR' stores a 3-byte value  (even though this isn't an addr)

  

LevelUp_ClassDataPointers:
.word data_LevelUpData_Class1
.word data_LevelUpData_Class2
.word data_LevelUpData_Class3
.word data_LevelUpData_Class4
.word data_LevelUpData_Class5
.word data_LevelUpData_Class6
.word data_LevelUpData_Class7
.word data_LevelUpData_Class8
.word data_LevelUpData_Class9
.word data_LevelUpData_Class10
.word data_LevelUpData_Class11
.word data_LevelUpData_Class12
.word data_LevelUpData_Class13
.word data_LevelUpData_Class14
.word data_LevelUpData_Class15
.word data_LevelUpData_Class16
.word data_LevelUpData_Class17
.word data_LevelUpData_Class18
.word data_LevelUpData_Class19
.word data_LevelUpData_Class20
.word data_LevelUpData_Class21
.word data_LevelUpData_Class22
.word data_LevelUpData_Class23
.word data_LevelUpData_Class24
.word data_LevelUpData_Class25
.word data_LevelUpData_Class26
.word data_LevelUpData_Class27
.word data_LevelUpData_Class28
.word data_LevelUpData_Class29
.word data_LevelUpData_Class30
.word data_LevelUpData_Class31
.word data_LevelUpData_Class32

LevelUp_HitRateBonus:
  .byte 3 ; 01 Fighter
  .byte 2 ; 02 Thief
  .byte 3 ; 03 BlackBelt
  .byte 2 ; 04 RedMage
  .byte 1 ; 05 WhiteMage
  .byte 1 ; 06 BlackMAge
  .byte 0 ; 07 Unused
  .byte 0 ; 08 Unused 
  .byte 0 ; 09 Unused 
  .byte 0 ; 10 Unused 
  .byte 0 ; 11 Unused 
  .byte 0 ; 12 Unused 
  .byte 0 ; 13 Unused 
  .byte 0 ; 14 Unused 
  .byte 0 ; 15 Unused 
  .byte 0 ; 16 Unused 
  .byte 3 ; 17 Knight
  .byte 2 ; 18 Ninja
  .byte 3 ; 19 Master
  .byte 2 ; 20 RedWizard
  .byte 1 ; 21 WhiteWizard
  .byte 1 ; 22 BlackWizard
  .byte 0 ; 23 Unused 
  .byte 0 ; 24 Unused   
  .byte 0 ; 25 Unused 
  .byte 0 ; 26 Unused
  .byte 0 ; 27 Unused 
  .byte 0 ; 28 Unused 
  .byte 0 ; 29 Unused 
  .byte 0 ; 30 Unused 
  .byte 0 ; 31 Unused 
  .byte 0 ; 32 Unused   
  

LevelUp_MagicDefenseBonus:
  .byte 2 ; 01 Fighter
  .byte 2 ; 02 Thief
  .byte 2 ; 03 BlackBelt
  .byte 1 ; 04 RedMage
  .byte 2 ; 05 WhiteMage
  .byte 3 ; 06 BlackMAge
  .byte 0 ; 07 Unused
  .byte 0 ; 08 Unused 
  .byte 0 ; 09 Unused 
  .byte 0 ; 10 Unused 
  .byte 0 ; 11 Unused 
  .byte 0 ; 12 Unused 
  .byte 0 ; 13 Unused 
  .byte 0 ; 14 Unused 
  .byte 0 ; 15 Unused 
  .byte 0 ; 16 Unused 
  .byte 2 ; 17 Knight
  .byte 2 ; 18 Ninja
  .byte 2 ; 19 Master
  .byte 4 ; 20 RedWizard
  .byte 2 ; 21 WhiteWizard
  .byte 3 ; 22 BlackWizard
  .byte 0 ; 23 Unused 
  .byte 0 ; 24 Unused   
  .byte 0 ; 25 Unused 
  .byte 0 ; 26 Unused
  .byte 0 ; 27 Unused 
  .byte 0 ; 28 Unused 
  .byte 0 ; 29 Unused 
  .byte 0 ; 30 Unused 
  .byte 0 ; 31 Unused 
  .byte 0 ; 32 Unused   
  

LevelUp_MPCap_LUT:
  .byte 0 ; 01 Fighter
  .byte 0 ; 02 Thief
  .byte 0 ; 03 BlackBelt
  .byte 9 ; 04 RedMage
  .byte 9 ; 05 WhiteMage
  .byte 9 ; 06 BlackMAge
  .byte 0 ; 07 Unused
  .byte 0 ; 08 Unused 
  .byte 0 ; 09 Unused 
  .byte 0 ; 10 Unused 
  .byte 0 ; 11 Unused 
  .byte 0 ; 12 Unused 
  .byte 0 ; 13 Unused 
  .byte 0 ; 14 Unused 
  .byte 0 ; 15 Unused 
  .byte 0 ; 16 Unused 
  .byte 4 ; 17 Knight
  .byte 4 ; 18 Ninja
  .byte 0 ; 19 Master
  .byte 9 ; 20 RedWizard
  .byte 9 ; 21 WhiteWizard
  .byte 9 ; 22 BlackWizard
  .byte 0 ; 23 Unused 
  .byte 0 ; 24 Unused   
  .byte 0 ; 25 Unused 
  .byte 0 ; 26 Unused
  .byte 0 ; 27 Unused 
  .byte 0 ; 28 Unused 
  .byte 0 ; 29 Unused 
  .byte 0 ; 30 Unused 
  .byte 0 ; 31 Unused 
  .byte 0 ; 32 Unused     



GetExpToNext:
    LDX char_index
    LDA ch_exp, X
    STA tmp+6
    LDA ch_exp+1, X
    STA tmp+7
    LDA ch_exp+2, X
    STA tmp+8         ; save current exp in tmp
    LDA ch_level, X
    CMP #50-1         ; see if they're level 50
    BNE :+            ; if so, clear output to 0 and return 
        SEC
        RTS
        
  : LDX #3            ; level * 3 because there's 3 bytes of exp data for each level
    JSR MultiplyXA
    TAX
    LDA lut_ExpToAdvance, X
    STA tmp+9
    LDA lut_ExpToAdvance+1, X
    STA tmp+10
    LDA lut_ExpToAdvance+2, X
    STA tmp+11
    CLC
    RTS



CheckForLevelUp:
    LDA #0
   @CharLoop: 
    STA char_index
    JSR GetExpToNext
    BCS @Next          ; they're level 50 already
    
    LDA tmp+8
    CMP tmp+11
    BEQ @Middle
    BCC @Next
    
   @Middle:
    LDA tmp+7
    CMP tmp+10
    BEQ @Low
    BCC @Next
    
   @Low:
    LDA tmp+6
    CMP tmp+9
    BCC @Next
    
    ;; carry was set by the last byte, so they have more exp than needed (or equal) to level
    
    JSR LevelUp
    ;JSR LevelUp_Messages
    LDA char_index
    JMP @CharLoop
    
   @Next:
    LDA char_index
    CLC
    ADC #$40
    BEQ @CharLoop
    RTS


LevelUp:
    ;JSR UnadjustEquipStats     ; remove equipment so it doesn't interfere with stat boosts
    
    LDX char_index
    LDA ch_level, X
    PHA                        ; back it up for just a bit 

    INC ch_level, X            ; add 1 to level
    LDA ch_level, X
    CLC
    ADC #1                     ; add 1 more for printing it
    STA LevelUp_PrintLevel     ; save new level for printing 
    LDA #0
    STA LevelUp_PrintLevel+1   ; high byte clear 
    
    LDA ch_class, X            ; get the pointers for the class's level up data
    ASL A
    TAY
    LDA LevelUp_ClassDataPointers, Y
    STA tmp
    LDA LevelUp_ClassDataPointers+1, Y
    STA tmp+1
    
    PLA                        ; pull old level
    ASL A                      ; * 2 and put in Y
    TAY
    LDA (tmp), Y                
    STA LevelUp_StatData       ; data for stat boosts
    INY
    LDA (tmp), Y                
    STA LevelUp_MPData         ; data for MP boosts
    
    LDA ch_class, X            ; use class to get magic defense bonus  
    TAY
    LDA LevelUp_MagicDefenseBonus, Y
    CLC
    ADC ch_magicdefense, X
    JSR CapAAt200
    STA ch_magicdefense, X      ; add and save the bonus
    
    LDA LevelUp_HitRateBonus, Y ; do the same for hit rate
    CLC
    ADC ch_hitrate, X
    JSR CapAAt200
    STA ch_hitrate, X
    
    LDA LevelUp_MPCap_LUT, Y     ; get max amount of MP per level for this class
    STA LevelUp_MPCap

    ;; do MP stuff!
    
    LDY #8                       ; use Y as a loop counter 
    LDA LevelUp_MPData
   @MP_Loop: 
    LSR A                        ; shift out the low bit
    BCC @Next_MP_NoPull
        PHA                      ; backup shifted MP data
        LDA ch_mp, X
        AND #$0F                 ; remove high bits (current MP)
        CMP LevelUp_MPCap        ; see if this level of MP is capped already
        BEQ @Next_MP             ; if so, skip it
        
        LDA ch_mp, X             ; else, add 1 to the low bits (max MP) and save
        CLC
        ADC #01
        STA ch_mp, X

   @Next_MP:
    PLA
   @Next_MP_NoPull: 
    INX                          ; move X to next MP byte                 
    DEY           
    BNE @MP_Loop 
    
    ;; now do stat boosts!
    ;; LevelUp_StatData bits are:
    ;; 00011111
    ;;    ^^^^^
    ;;    |||||  Stat:     Loop Iteration:
    ;;    ||||-- Speed     (4) first
    ;;    |||--- Vitality  (3) second
    ;;    ||---- Intellect (2) third
    ;;    |----- Agility   (1) fourth
    ;;    ------ Strength  (0) fifth
    
    LDA #4
    STA tmp                       ; loop counter
    
   @StatUpdate_Loop: 
    LSR LevelUp_StatData
    BCS @IncreaseStat             ; if set, increase the stat

   @RandomChance:                 ; else...
    JSR BattleRNG_L               ; get a random number
    AND #$03
    BEQ @IncreaseStat             ; if its 0, (25% chance), increase it
    LDA #0                        ; else, set the stat buffer byte for this stat to 0
    BEQ @NextStat
    
   @IncreaseStat:
    LDA char_index
    CLC
    ADC tmp                       ; add loop counter to char_index to get proper stat
    TAX
    INC ch_mainstats, X           ; increment the stat     
    LDA ch_mainstats, X
    CMP #100
    BNE @NextStat
      DEC ch_mainstats, X         ; oops, it was over 100, decrement it back to 99
      LDA ch_mainstats, X
    
   @NextStat:                     ; A = 0 from failing the random chance, or the new stat
    LDY tmp
    STA LevelUp_StatBuffer, Y     ; fill the buffer that tells the level up boxes what messages to display
    
    DEY
    STY tmp
    BPL @StatUpdate_Loop          ; end loop when counter rolls over to $FF
    
    
   ;; Damage and Evade:
   
   LDA LevelUp_StatBuffer         ; first byte is strength
   BEQ @Evasion
    LDA ch_strength, X            ; damage goes up 1 pt for each 2pts of strength
    LSR A                         
    BCS @Evasion                  ; ...see if it went up to an even number
    LDA ch_damage, X
    CLC
    ADC #1
    JSR CapAAt200
    STA ch_damage, X

  @Evasion: 
   LDA LevelUp_StatBuffer+1       ; evade goes up 1 if agility went up
   BEQ @HP
    LDA ch_evasion, X
    CLC
    ADC #1
    JSR CapAAt200
    STA ch_evasion, X
   
   ;; and finally, HP
   
   @HP:
    LDX char_index
    LDA ch_vitality, X
    LSR A
    LSR A
    CLC
    ADC #01                       ; base HP bonus is vitality / 4 + 1 
    PHA                     
   
    LDA LevelUp_StatData
    AND #$01                      ; is the strong level up bit set? (it was shifted into the lowest bit)
    BEQ :+
        LDA #20                   ; if it is, get between 20-25 extra HP 
        LDX #25
        JSR RandAX
  : STA tmp                       ; store the bonus here (0 if the level up bit was not set!)
    PLA                           ; pull base HP bonus
    CLC
    ADC tmp                       ; add strong bonus, if it exists
    
    LDX char_index                ; reset X to char_index
    ADC ch_basehp, X              ; add level up HP bonus to base max HP
    STA ch_basehp, X
    STA LevelUp_PrintHP           ; and put the new base max into this, for printing
    LDA ch_basehp+1, X
    ADC #0
    STA ch_basehp+1, X            ; save any carry-over
    STA LevelUp_PrintHP+1
    CMP #HP_MAX_HIGH              ; now compare to max possible values ($03)
    BCC @Finished                 ; if its $00, $01, $02, skip ahead
    
   @CheckLowHP:
    LDA #HP_MAX_HIGH              ; in case it was over 3, save it as 3
    STA ch_basehp+1, X   
    STA LevelUp_PrintHP+1
    
    LDA ch_basehp, X              ; compare low byte to max value ($E7)
    CMP #HP_MAX_LOW
    BCC @Finished                 ; if that is also under, skip ahead
        LDA #HP_MAX_LOW           ; otherwise, set HP to max value (high byte already = its own max value)
        STA ch_basehp, X
        STA LevelUp_PrintHP       ; and update the printing byte as well    
    
   @Finished:    
    ;JMP ReadjustEquipStats        ; and re-do all the substats with the new base stats!
    RTS


CapAAt200:
    CMP #201
    BCC :+
      LDA #200
  : RTS








































































;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Assign Map Tile Damage [$C861 :: 0x3C871]
;;
;;    Deals 1 damage to all party members (for standard map damaging tiles
;;  -- Frost/Lava).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


AssignMapTileDamage_Z:
    LDX #$00              ; zero loop counter and char index

  @Loop:
    LDA ch_curhp+1, X     ; check high byte of HP
    BNE @DmgSubtract      ; if nonzero (> 255 HP), deal this guy damage

    LDA ch_curhp, X       ; otherwise, check low byte
    CMP #2                ; if < 2, skip damage (don't take away their last HP)
    BCC @DmgSkip

  @DmgSubtract:
    LDA ch_curhp, X       ; subtract 1 HP
    SEC
    SBC #1
    STA ch_curhp, X
    LDA ch_curhp+1, X
    SBC #0
    STA ch_curhp+1, X

  @DmgSkip:
    TXA                   ; add $40 to char index (next character in party)
    CLC
    ADC #$40
    TAX

    BNE @Loop             ; loop until it wraps (4 iterations)
   
   @Nah: 
    LDA cur_bank
    JMP SwapPRG_L         ; then exit




MapPoisonDamage_Z:
    LDA #1
    LDX #5
    JSR RandAX     ; get between 1-5 damage to deal out
    STA tmp+1

    LDY #0         ; X will be our loop counter and char index
  @DmgLoop:
    LDA ch_ailments, Y    ; get this character's ailments
    AND #AIL_POISON       ; see if they're poisoned
    BEQ @DmgSkip          ; if not... skip this character
    
    LDA tmp+1
    STA tmp

    LDA ch_curhp+1, Y     ; check high byte of HP
    BNE @DmgSubtract      ; if nonzero (> 255 HP), deal this character damage

    LDA ch_curhp, Y
    CMP #1                ; skip if their HP is only 1  
    BEQ @DmgSkip

  @FindNewDamage:
    LDA tmp               ; otherwise, check low byte of HP
    CMP ch_curhp, Y       ; see if they have as much HP as there is damage 
    BCC @DmgSubtract      ; C set if they will die from it, so skip 
    
    DEC tmp
    JMP @FindNewDamage

  @DmgSubtract:
    LDA ch_curhp, Y       ; subtract 1 from HP
    SEC
    SBC tmp
    STA ch_curhp, Y
    LDA ch_curhp+1, Y
    SBC #0
    STA ch_curhp+1, Y

  @DmgSkip:
    TYA                   ; add $40 char index
    CLC
    ADC #$40
    TAY
    BNE @DmgLoop          ; and loop until it wraps (4 iterations)
    
   @Random:               ; then figure out how many steps until the next poison
    LDA #4
    LDX #8
    JSR RandAX
    STA domappoison
    LDA #$1E
    STA btl_soft2001      ; and remove red emphasis (reset soft2001 to normal use)
    LDA cur_bank
    JMP SwapPRG_L












  lut_IntroStoryText:

;; JIGS - the original used DTE, which my routine can not... so I did my best to re-make it with some fancy tweaks.
;; Since every letter is a sprite as well, we can't use control codes. So the routine uses $78 (sprite the same colour as the background)
;; and reads them as double line breaks.
;; The screen is 32 tiles wide, so...
     ; 1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32

.byte $FF,$FF,$FF,$FF,$9D,$AB,$A8,$FF,$BA,$B2,$B5,$AF,$A7,$FF,$AC,$B6,$FF,$B9,$A8,$AC,$AF,$A8,$A7,$FF,$AC,$B1,$70
.byte $FF,$FF,$A7,$A4,$B5,$AE,$B1,$A8,$B6,$B6,$C0,$FF,$FF,$9D,$AB,$A8,$FF,$BA,$AC,$B1,$A7,$FF,$B6,$B7,$B2,$B3,$B6,$BF,$70
.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$B7,$AB,$A8,$FF,$B6,$A8,$A4,$FF,$AC,$B6,$FF,$BA,$AC,$AF,$A7,$BF,$70
.byte $FF,$A4,$B1,$A7,$FF,$B7,$AB,$A8,$FF,$A8,$A4,$B5,$B7,$AB,$FF,$A5,$A8,$AA,$AC,$B1,$B6,$FF,$B7,$B2,$FF,$B5,$B2,$B7,$C0,$70
.byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$9D,$AB,$A8,$FF,$B3,$A8,$B2,$B3,$AF,$A8,$FF,$BA,$A4,$AC,$B7,$BF,$FF,$70
.byte $B7,$AB,$A8,$AC,$B5,$FF,$B2,$B1,$AF,$BC,$FF,$AB,$B2,$B3,$A8,$BF,$FF,$A4,$FF,$B3,$B5,$B2,$B3,$AB,$A8,$A6,$BC,$C3,$C0,$70,$70
.byte $C6,$A0,$AB,$A8,$B1,$FF,$B7,$AB,$A8,$FF,$BA,$B2,$B5,$AF,$A7,$FF,$AC,$B6,$FF,$AC,$B1,$FF,$A7,$A4,$B5,$AE,$B1,$A8,$B6,$B6,$70
.byte $FF,$FF,$FF,$8F,$B2,$B8,$B5,$FF,$A0,$A4,$B5,$B5,$AC,$B2,$B5,$B6,$FF,$BA,$AC,$AF,$AF,$FF,$A6,$B2,$B0,$A8,$C3,$7E,$70,$70
.byte $FF,$FF,$FF,$FF,$FF,$8A,$A9,$B7,$A8,$B5,$FF,$A4,$FF,$AF,$B2,$B1,$AA,$FF,$AD,$B2,$B8,$B5,$B1,$A8,$BC,$BF,$70
.byte $FF,$FF,$A9,$B2,$B8,$B5,$FF,$BC,$B2,$B8,$B1,$AA,$FF,$BA,$A4,$B5,$B5,$AC,$B2,$B5,$B6,$FF,$A4,$B5,$B5,$AC,$B9,$A8,$BF,$70
.byte $FF,$FF,$FF,$FF,$FF,$A8,$A4,$A6,$AB,$FF,$AB,$B2,$AF,$A7,$AC,$B1,$AA,$FF,$A4,$B1,$FF,$98,$9B,$8B,$C0,$00
;; It's the intro text... I'm not gonna spell it out here. :I I just made some edits to spiff it up a bit. Some spaces here, a better ... there, added in a proper ` for the quotation part...


JigsIntro:
    LDA #$10
    STA shop_id
    
    ;; some prep work done in LoadShopCHRForBank_Z in Bank $04 -- turns off screen, sets soft2000, and loads Shop graphics (intro sprites as well)
    ;; The shop graphics have the extra .' tile this screen uses, as well as loading the menu text.
    JSR LongCall
    .word LoadShopCHRForBank_Z
    .byte BANK_MENUCHR

    LDA #$FF
    STA MMC5_tmp
    JSR ClearNT
    JSR ClearButtons
    STA cursor
    STA joy_prevdir        ; as well as resetting the cursor and previous joy direction

    LDA $2002           ; reset PPU toggle and set PPU address to $2000
    LDA #>$23C0         ;   (start of nametable)
    STA $2006
    LDA #<$23C0
    STA $2006

    LDX #$40            ; Next, fill the attribute table so that all tiles use
    LDA #$00            ;  palette 0.
  @AttrLoop:            ;
      STA $2007         ;
      DEX
      BNE @AttrLoop

    LDA #$01
    STA cur_pal
    STA cur_pal+2
    STA cur_pal+$10
    STA cur_pal+$12
    LDA #$30
    STA cur_pal+3

    LDA #<lut_IntroStoryText  ; load up the pointer to the intro story text
    STA text_ptr
    LDA #>lut_IntroStoryText
    STA text_ptr+1

    LDA #$0D ; 09                ; starting sprite coordinates
    STA spr_x
    LDA #$14 ; 10
    STA spr_y

    LDX #2                  ; Text coordinates
    STX dest_y
    DEX ; #1
    STX dest_x

    JSR TurnMenuScreenOn_ClearOAM

IntroLoop:
    LDA #4
    STA tmp+6

   @loop:
    JSR NextLetter           ; gets the next tile to print, set it up in OAM, updates the sprite palette
    JSR TurnOnScreen         ; does all the frame work! Loads the new palette, updates sprites, sets scroll, does music...
    JSR UpdateJoy         ; Update joypad data
    LDA joy
    AND #BTN_START        ; see if start was pressed
    BEQ :+                ; if not, skip ahead.
        LDA #0
        STA $2001              ; turn off the PPU
        STA joy_a              ; clear A, B, Start button catchers
        STA joy_b
        STA joy_start
        STA cursor
        STA joy_prevdir        ; as well as resetting the cursor and previous joy direction
        RTS

  : DEC tmp+6
    BNE @loop
    ;; Do 4 frames, then...

    JSR IntroStoryText
    JMP IntroLoop


NextLetter:
    LDX sprindex     ; get the sprite index in X
    LDY #0
    LDA (text_ptr), Y
    STA oam+$1, X    ; write it to oam

    DEC spr_y        ; DEC the coordinates every frame to give it that "popping out" effect
    LDA spr_y
    STA oam+$0, X    ;  set Y coords
    DEC spr_x
    LDA spr_x
    STA oam+$3, X    ;  set X coords

    LDA #$04
    STA oam+$2, X    ; write to oam
    ;; flow into

IntroSpritePalette:
    LDA tmp+6
    CMP #03         ; on frame 1 and 2 (loop counter = 4 or 3), do dark
    BCS @Darkest

   @Darker:          ; on frame 3 and 4 (loop counter = 2 or 1), do light
    LDA #$21
    STA cur_pal+19
    RTS

   @Darkest:
    LDA #$11
    STA cur_pal+19
    RTS


IntroStoryText:
    LDA #1
    STA menustall         ; enable to write while PPU is on?
    JSR CoordToNTAddr
    JSR MenuCondStall

   @Draw:
    LDY #0            ; zero Y -- we don't want to use it as an index.  Rather, the pointer is updated
    LDA (text_ptr), Y ;   after each fetch
    BEQ @Finish       ; if the character is 0  (null terminator), exit the routine

    INC text_ptr      ; otherwise, inc source pointer
    BNE :+
      INC text_ptr+1  ;   inc high byte if low byte wrapped

:   CMP #$70
    BEQ @ControlCode  ;   if it is, jump ahead

    LDX $2002         ; reset PPU toggle
    LDX ppu_dest+1    ;  load and set desired PPU address
    STX $2006         ;  do this with X, as to not disturb A, which is still our character
    LDX ppu_dest
    STX $2006

    STA $2007          ; draw the character as-is
    INC ppu_dest       ; increment dest PPU address
    JMP @DrawText_Exit ; and finish after printing one letter

   @ControlCode:
    LDA #1
    STA dest_x
    INC dest_y
    INC dest_y
    LDA spr_y
    CLC
    ADC #$14 ; 10
    STA spr_y         ; update sprite Y coordinates to next line
    LDA #$0D ; 9
    STA spr_x         ; and reset sprite X
    JMP @Finish

   @DrawText_Exit:
    INC dest_x
    INC MMC5_tmp+7

    LDA spr_y
    CLC
    ADC #$4
    STA spr_y

    LDA spr_x
    CLC
    ADC #$0C ; 08
    STA spr_x

   @Finish:
    LDA #$00          ; reset scroll to 0
    STA $2005
    STA $2005
    RTS


ClearButtons:
    LDA #0
    STA joy_a              ; clear A, B, Start button catchers
    STA joy_b
    STA joy_start
    STA joy_select
    RTS


TurnMenuScreenOn_ClearOAM:
    JSR ClearOAM
TurnOnScreen:
    JSR WaitForVBlank_L      ; wait for VBlank (don't want to turn the screen on midway through the frame)
    LDA #>oam                ; do Sprite DMA
    STA $4014
    JSR DrawPalette          ; draw/apply the current palette

    LDA #$08
    STA soft2000             ; set $2000 and soft2000 appropriately
    STA $2000                ;  (no NT scroll, BG uses left pattern table, sprites use right, etc)

    LDA #$1E
    STA $2001                ; enable BG and sprite rendering
    LDA #0
    STA $2005
    STA $2005                ; reset scroll

    LDA #BANK_THIS           ; record current bank and CallMusicPlay
    STA cur_bank
    JMP CallMusicPlay




EnterTitleScreen:
    LDA #$08               ; set soft2000 so that sprites use right pattern
    STA soft2000           ;   table while BG uses left

    JSR ClearButtons       ; resets all buttons and A = 0
    STA weasels            ; needs to be 0 or else the SaveScreen will try to SAVE instead of LOAD
    STA $2001              ; turn off the PPU
    STA cursor
    STA joy_prevdir        ; as well as resetting the cursor and previous joy direction

    LDA #$0F
    STA cur_pal+$0E

    JSR DrawTitleWords
    JSR TurnMenuScreenOn_ClearOAM

    LDA #3
    STA cursor_max

   @Loop:
    JSR ClearOAM
    JSR DrawTitleCursor
    JSR WaitForVBlank_L
    LDA #>oam
    STA $4014
    LDA #0
    STA $2005
    STA $2005

    LDA #BANK_THIS
    STA cur_bank
    JSR CallMusicPlay

    JSR UpdateJoy
    LDA joy_a
    ORA joy_start
    BNE @OptionChosen

    LDA joy
    AND #$0C          ; isolate Up/down directions
    CMP joy_prevdir   ; if its the same as last frame, do nothing
    BEQ @Loop

    STA joy_prevdir   ; save the new direction press
    CMP #0            ; see if the change was buttons being pressed or lifted
    BEQ @Loop         ; if buttons were being lifted, do nothing (keep looping)

    CMP #$04          ; see if it was down
    BNE @Up

   @Down:
    INC cursor
    LDA cursor
    CMP cursor_max
    BCC @MoveOK
    LDA #0
    BEQ @MoveOK

   @Up:
    DEC cursor
    LDA cursor
    BPL @MoveOK
    LDX cursor_max
    DEX
    TXA             ; A = 1 less than cursor_max

   @MoveOK:
    STA cursor
    JSR PlaySFX_MenuMove
    JMP @Loop

   @OptionChosen:
    LDA cursor
    CMP #2
    BEQ TitleScreen_OptionsMenu
    CMP #1           ; this will set C, indicating new game or continue
    BCS StartNewGame
    
    ; Otherwise, they selected "Continue"...
    JSR SaveScreen
    BCS ReenterTitleScreen            ; jump back to title screen if B was pressed     
    RTS

StartNewGame: 
    JSR NewGamePartyGeneration      ; create a new party
    BCS ReenterTitleScreen
    JMP NewGame_LoadStartingStats   ;   and set their starting stats
    ;JMP ReadjustEquipStats ;; JIGS - apply weapon stats to the starting weapons    

TitleScreen_OptionsMenu:
    LDA #0
    STA $2001                         ; turn off the screen and menustall
    STA menustall
    LDX BattleBGColor                 ; Options screen uses the battle BG color (so you can see what you're choosing!)
    LDA BattleBackgroundColor_LUT, X
    STA cur_pal+14
    JSR ClearNT                       ; Clear and fill the background with a tile other than $00
    JSR OptionsMenu                   ; Do the options menu!

ReenterTitleScreen:
    LDA #0
    STA $2001      
    JSR ReloadBridgeNT
    JMP EnterTitleScreen

DrawTitleCursor:
    LDY cursor                   ; put the cursor in Y
    LDA lut_TitleCursor_Y, Y     ; get the Y position
    STA spr_y
    LDA #$38                     ; X position is always the same
    STA spr_x
    JMP DrawCursor               ; draw it!  and exit

lut_TitleCursor_Y:
   .BYTE $38,$48,$58



NewGame_LoadStartingStats:
    LDA #$00                ; load up the starting stats for each character
    JSR @LoadStats
    LDA #$40
    JSR @LoadStats
    LDA #$80
    JSR @LoadStats
    LDA #$C0

  @LoadStats:
    PHA
    TAX
    LDA ch_class, X         ; get the class
    LDX #STARTING_STATS
    JSR MultiplyXA
    TAY                     ; source index in Y
    PLA
    TAX
    
    ;; lut_ClassStartingStats table contains $D bytes of data
    
    LDA lut_ClassStartingStats, Y ; starting HP
    STA ch_basehp, X
    STA ch_curhp, X

    LDA lut_ClassStartingStats+1, Y ; base stats
    STA ch_strength, X
    LDA lut_ClassStartingStats+2, Y
    STA ch_agility, X
    LDA lut_ClassStartingStats+3, Y
    STA ch_intelligence, X
    LDA lut_ClassStartingStats+4, Y
    STA ch_vitality, X
    LDA lut_ClassStartingStats+5, Y
    STA ch_speed, X
    
    LDA lut_ClassStartingStats+6, Y ; sub stats
    STA ch_damage, X
    LDA lut_ClassStartingStats+7, Y
    STA ch_hitrate, X
    LDA lut_ClassStartingStats+8, Y
    STA ch_evasion, X
    LDA lut_ClassStartingStats+$9, Y
    STA ch_magicdefense, X
    
    ;; JIGS: You can use the padding in lut_ClassStartingStats to tell the game
	;; how much mana to give! Or start with a fancy weapon! Even a spell!

    LDA lut_ClassStartingStats+$A, Y
    STA ch_mp, X
    LDA lut_ClassStartingStats+$B, Y
    STA ch_righthand, X
    LDA lut_ClassStartingStats+$C, Y
    STA ch_body, X
    LDA lut_ClassStartingStats+$D, Y
    STA ch_spells, X
	RTS
    
    ;; JIGS - starting stats does this now!
    ; Award starting MP if the class ID is >= RM, but < KN
  ;  LDA ch_class, X
  ;  CMP #CLS_RM
  ;  BCC :+
  ;    CMP #CLS_KN
  ;    BCS :+
  ;      ;LDA #$02                ; start with 2 MP
  ;      ;STA ch_curmp, X
  ;      ;STA ch_maxmp, X
  ;      LDA #$22    ; JIGS - high bits are current, low bits are max. One byte.
  ;      STA ch_mp, X
  ;   : RTS 

  





























ClearNT:
    LDA $2002     ; reset PPU toggle
    LDA #$20
    STA $2006
    LDA #$00
    STA $2006     ; set PPU addr to $2000 (start of NT)
    LDA #$00
    LDX #$F0      ; $03C0 / 4 = $F0.
    LDY #$40

@Loop:            ; first loop clears the first $0300 bytes of the NT
      STA $2007
      STA $2007
      STA $2007
      STA $2007
      DEX          ;  decrement X
      BNE @Loop    ;  and stop looping once X expires

    LDA #$FF      ; A=FF (this is what we will fill attribute table with
@Loop2:           ;  2nd loop fills the last $40 bytes (attribute table) with FF
      STA $2007
      DEY
      BNE @Loop2
    RTS






DrawTitleWords:
    LDX #0
    JSR @DrawString
    ; JSR to the @DrawString to draw the first one, then just let code flow into it to draw a second one
    JSR @DrawString
    ;; JIGS -- draw 1 more, 3 in total. Added some stuff below.

  @DrawString:
    LDA @lut_TitleText+1, X ; get the Target PPU address from the LUT
    STA $2006
    LDA @lut_TitleText, X
    STA $2006
    INX                     ; move X past the address we just read
    INX

  @Loop:
    LDA @lut_TitleText, X   ; get the next character in the string
    BEQ @Exit               ;  if it's zero, exit (null terminator
    STA $2007               ; otherwise, draw the character
    INX                     ; INX to move to next character
    BNE @Loop               ; and keep looping (always branches)

  @Exit:
    INX                     ; INX to move X past the null terminator we just read
    RTS

 ;; LUT for the copyright text.  Simply a 2-byte target PPU address, followed by a
 ;;  null terminated string.  Two strings total.

@lut_TitleText:
   .WORD $20E9
   .BYTE $8C,$98,$97,$9D,$92,$97,$9E,$8E,$00 ; CONTINUE
   .WORD $2129
   .BYTE $97,$8E,$A0,$FF,$90,$8A,$96,$8E,$00 ; NEW GAME
   .WORD $2169
   .BYTE $98,$99,$9D,$92,$98,$97,$9C,$00     ; OPTIONS
   ;.WORD $2328
   ;.BYTE $8C,$FF,$81,$89,$88,$87,$FF,$9C,$9A,$9E,$8A,$9B,$8E,$00  ; "C 1987 SQUARE  "
   ;.WORD $2348
   ;.BYTE $8C,$FF,$81,$89,$89,$80,$FF,$97,$92,$97,$9D,$8E,$97,$8D,$98,$00  ; "C 1990 NINTENDO"

   ;; JIGS - using the bridge scene, it already has this info.






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  NewGamePartyGeneration  [$9C54 :: 0x39C64]
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NewGamePartyGeneration:
    LDA #$00                ; turn off the PPU
    STA $2001

    LDA #$01
    STA cur_pal+$0E

    LDX #$1E
    LDA #$FE
    JSR SetPPUAddr_XA
    LDA #$7F
    STA $2007
    ;; this will draw a _ on a blank tile, for the blinker

    LDX #$4B        ; Initialize the ptygen buffer!
    ;;  JIGS - bigger buffer! Buff buffer.
    : LDA lut_PtyGenBuf, X  ;  all $40 bytes!  ($10 bytes per character)
      STA ptygen, X
      DEX
      BPL :-

  @Char_0:                      ; To Character generation for each of the 4 characters
    LDA #$00                    ;   branching back to the previous char if the user
    STA char_index              ;   cancelled by pressing B
    JSR DoPartyGen_OnCharacter
    BCC @Char_1
    RTS 
    ;; JIGS ^ if you accidentally clicked new game... carry is set
  @Char_1:
    LDA #$13  ;; JIGS - every character has 3 more bytes in ptygen now
    STA char_index
    JSR DoPartyGen_OnCharacter
    BCS @Char_0
  @Char_2:
    LDA #$26
    STA char_index
    JSR DoPartyGen_OnCharacter
    BCS @Char_1
  @Char_3:
    LDA #$39
    STA char_index
    JSR DoPartyGen_OnCharacter
    BCS @Char_2


    ; Once all 4 characters have been generated and named...
    JSR PtyGen_DrawScreen       ; Draw the screen one more time
    JSR ClearOAM                ; Clear OAM
    JSR PtyGen_DrawChars        ; Redraw char sprites
    JSR WaitForVBlank_L         ; Do a frame
    LDA #>oam                   ;   with a proper OAM update
    STA $4014

    JSR MenuWaitForBtn_SFX      ; Wait for the user to press A (or B) again, to
    LDA joy                     ;  confirm their party decisions.
    AND #$40
    BNE @Char_3                 ; If they pressed B, jump back to Char 3 generation

    ;;  Otherwise, they've pressed A!  Party confirmed!
    LDA #$00
    STA $2001                   ; shut the PPU off

    LDX #$00                    ; Move class and name selection
    JSR @RecordClassAndName     ;  out of the ptygen buffer and into the actual character stats
    LDX #$13
    JSR @RecordClassAndName
    LDX #$26
    JSR @RecordClassAndName
    LDX #$39

  @RecordClassAndName:
    TXA                     ; X is the ptygen source index  ($10 bytes per character)

  ;; JIGS - X needs to be 0, 13, 26, and 39
  ;;        Y needs to be 0, 10, 20, and 30, ASL A'd twice
    AND #$F0                ; - so cut off low byte!

    ASL A
    ASL A
    TAY                     ; Y is the ch_stats dest index  ($40 bytes per character)

    LDA ptygen_sprite, X ; get sprite
    STA ch_sprite, Y

    LDA ptygen_class, X  ; get class
    STA ch_class, Y      ; and save!

    LDA #7
    STA tmp

   @NameLoop:
    LDA ptygen_name, X ; then save name!
    STA ch_name, Y
    INY
    INX
    DEC tmp
    BNE @NameLoop

    LDA #0
    STA playtimer
    STA playtimer+1
    STA playtimer+2
    STA playtimer+3   ; and reset the timer to 0
    CLC
    RTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawScreen  [$9CF8 :: 0x39D08]
;;
;;    Prepares and draws the Party Generation screen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawScreen:
    LDA #$08
    STA soft2000          ; set BG/Spr pattern table assignments
    JSR ClearButtons      ; A = 0
    STA cursor
    STA joy_prevdir       ; as well as resetting the cursor and previous joy direction
    STA $2001             ; turn off PPU

    JSR ClearNT 
    JSR PtyGen_DrawBoxes
    JSR PtyGen_DrawText
    
    LDA #05 
    STA dest_x 
    LDA #26
    STA dest_y
    
    LDA #$0E
    JSR DrawZ_MenuString
    
    LDA #<$23F0
    LDX #>$23F0
    JSR SetPPUAddr_XA

    LDA #$0F
    LDX #$08
  : STA $2007
    DEX
    BPL :-
    ;; set the nametable attributes  
    ;LDA #$0F
    STA cur_pal+2
    ;; make palette 0 have black instead of blue    
    
    JMP TurnMenuScreenOn_ClearOAM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  DoPartyGen_OnCharacter  [$9D15 :: 0x39D25]
;;
;;    Does character selection and name input for one character.
;;
;;  input:      ptygen = should be filled appropriately
;;          char_index = $00, 10, 20, 30 to indicate which character's name we're setting
;;
;;  output:    C is cleared if the user confirmed/named their character
;;             C is set if the user pressed B to cancel/go back
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoPartyGen_OnCharacter:
    JSR PtyGen_DrawScreen           ; Draw the Party generation screen

    ; Then enter the main logic loop
  @MainLoop:
    JSR PtyGen_Frame              ; Do a frame and update joypad input
    LDA joy_a
    BNE DoNameInput               ; if A was pressed, do name input
    LDA joy_b
    BEQ :+
      ; if B pressed -- just SEC and exit
      SEC
      RTS

    ; Code reaches here if A/B were not pressed
  : LDA joy
    AND #$0F
    CMP joy_prevdir
    BEQ @MainLoop             ; if there was no change in directional input, loop to another frame

    STA joy_prevdir           ; otherwise, record new directional input as prevdir
    CMP #$00                  ; if directional input released (rather than pressed)
    BEQ @MainLoop             ;   loop to another frame.

    ;; JIGS-- Left/Right now change the class, Up/Down change the sprite.
    CMP #$02  ; if left is pressed
      BEQ @ReverseCharThing
    CMP #$04  ; or if down is pressed
      BEQ @CharSpriteThing
    CMP #$08  ; or if up is pressed
      BEQ @ReverseCharSpriteThing


   ; Otherwise, if any direction was pressed:
    LDX char_index
    CLC
    LDA ptygen_class, X       ; Add 1 to the class ID of the current character.
    ADC #1
    CMP #CLASS_START_MAX      ; JIGS - change this to 12 for all classes
    BCC :+
      LDA #0                  ; wrap 5->0
  : STA ptygen_class, X

    LDA #$01                  ; set menustall (drawing while PPU is on)
    STA menustall
    LDX char_index            ; then update the on-screen class name
    JSR PtyGen_DrawOneText
    JMP @MainLoop

   @ReverseCharThing:
    LDX char_index
    LDA ptygen_class, X       ; Subtract 1 from the class ID of the current character.
    SEC
    SBC #1
    CMP #CLASS_START_MAX      ; JIGS - change this to 12 for all classes
    BCC :-
    LDA #CLASS_START_MAX-1    ; JIGS - and then change this to 11
    BNE :-

   @CharSpriteThing:
    LDX char_index
    LDA ptygen_sprite, X
    CLC
    ADC #1
    CMP #CLASS_START_MAX      ; JIGS - change this to 12 for all classes
    BCC :+
       LDA #0
  : STA ptygen_sprite, X
    JMP @MainLoop

   @ReverseCharSpriteThing:
    LDX char_index
    LDA ptygen_sprite, X      ; Subtract 1 from the sprite ID of the current character.
    SEC
    SBC #1
    CMP #CLASS_START_MAX      ; JIGS - change this to 12 for all classes
    BCC :-
    LDA #CLASS_START_MAX-1    ; JIGS - and then change this to 11
    BNE :-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  DoNameInput  [$9D50 :: 0x39D60]
;;
;;    Does the name input screen.  Draw the screen, gets the name, etc, etc.
;;
;;  input:      ptygen = should be filled appropriately
;;          char_index = $00, 10, 20, 30 to indicate which character's name we're setting
;;
;;  output:    C is cleared to indicate name successfully input
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoNameInput:
    LDA #$00                ; Turn off the PPU (for drawing)
    STA $2001

    STA menustall           ; zero a bunch of misc vars being used here
    STA joy_a
    STA joy_b
    STA joy_start
    STA joy
    STA joy_prevdir

   ; STA cursor              ; letter of the name we're inputting (0-3)
    STA cursor_x          ; X position of letter selection cursor (0-9)
    STA cursor_y          ; Y position (0-6)

    ; Some local temp vars
    @selectedtile   = tmp

    JSR ClearNT
    JSR DrawNameInputScreen
    JSR NameInput_DrawName

    ;Write $00 to $1C97
    LDY $2002
    LDX #$1C
    STX $2006
    LDY #$97
    STY $2006
    LDA #0
    STA $2007
    ;; JIGS - this turns part of the beam spell graphic into a white _

    JSR TurnMenuScreenOn_ClearOAM   ; now that everything is drawn, turn the screen on

    LDX char_index
    LDY #0
   @FindCursorLoop:
    LDA ptygen_name, X
    CMP #$FF
    BEQ :+
    INX
    INY
    CPX #7
    BNE @FindCursorLoop
  : STY cursor

    INC menustall
    ;LDA #$01                ; Set menustall, as future drawing will
    ;STA menustall           ;  be with the PPU on
    JMP @MainLoop

    ;;;;;;;;;;;;;;;;;;


  @Start_Pressed:
    JSR PlaySFX_MenuSel
    LDY #0
    STY joy_start
    CLC                 ; CLC to indicate name was successfully input
    RTS

  @MainLoop:
    JSR CharName_Frame      ; Do a frame & get input

    LDA joy_start
    BNE @Start_Pressed
    LDA joy_a
    BNE @A_Pressed          ; Check if A or B pressed
    LDA joy_b
    BNE @B_Pressed

    LDA joy                 ; Otherwise see if D-pad state has changed
    AND #$0F
    CMP joy_prevdir
    BEQ @MainLoop           ; no change?  Jump back
    STA joy_prevdir

    ; D-pad state has changed, see what it changed to
    CMP #$00
    BEQ @MainLoop           ; if released, do nothing and loop

    CMP #$04
    BCC @Left_Or_Right      ; if < 4, L or R pressed

    CMP #$08                ; otherwise, if == 8, Up pressed
    BNE @Down               ; otherwise, if != 8, Down pressed

   @Up:
    DEC cursor_y          ; DEC cursor Y position
    BPL @MainLoop
    LDA #$06                ; wrap 0->6
    STA cursor_y
    JMP @MainLoop

   @Down:
    INC cursor_y          ; INC cursor Y position
    LDA cursor_y
    CMP #$07                ; wrap 6->0
    BCC @MainLoop
    LDA #$00
    STA cursor_y
    JMP @MainLoop

   @Left_Or_Right:
    CMP #$02                ; if D-pad state == 2, Left pressed
    BNE @Right              ; else, Right pressed

   @Left:
    DEC cursor_x          ; DEC cursor X position
    BPL @MainLoop
    LDA #$09                ; wrap 0->9
    STA cursor_x
    JMP @MainLoop

   @Right:
    INC cursor_x          ; INC cursor X position
    LDA cursor_x
    CMP #$0A                ; wrap 9->0
    BCC @MainLoop
    LDA #$00
    STA cursor_x
    JMP @MainLoop

   @B_Pressed:
    LDA #$FF                ; if B was pressed, erase the previous tile
    STA @selectedtile       ;   by setting selectedtile to be a space

    LDA cursor              ; then by pre-emptively moving the cursor back
    SEC                     ;   so @SetTile will overwrite the prev char
    SBC #$01                ;   instead of the next one
      STA cursor
      CMP #$FF
      BEQ @B_RTS

    LDA #$00                ; set cursoradd to 0 so @SetTile doesn't change
    STA cursoradd           ; the cursor
    STA joy_b               ; clear joy_b as well
    BEQ @SetTile            ; (always branches)

   @B_RTS:
    JMP DoPartyGen_OnCharacter

    ;;;;;;;;;;;;;;;;;;
   @A_Pressed:
    LDX cursor_y                  ; when A is pressed, clear joy_a
    LDA #$00
    STA joy_a                       ; Then get the tile they selected by first
    LDA lut_NameInputRowStart, X    ;  running the Y cursor through a row lut
    CLC
    ADC cursor_x                  ; add X cursor
    ASL A                           ; and multiply by 2 -- since there are spaces between tiles
    TAX                             ; use that value as an index to the lut_NameInput
    LDA lut_NameInput, X
    STA @selectedtile               ; record selected tile
    LDA #$01
    STA cursoradd                   ; set cursoradd to 1 to indicate we want @SetTile to move the cursor forward

    LDA cursor                      ; check current cursor position
    CMP #$07                        ;  If we've already input 7 letters for this name....
    BCS @Done                       ;  .. then we're done.  Branch ahead
                                    ; Otherwise, fall through to SetTile

   @SetTile:
    LDA cursor                  ; use cursor and char_index to access the appropriate
    CLC                         ;   letter in this character's name
    ADC char_index
    TAX
    LDA @selectedtile
    STA ptygen_name, X          ; and write the selected tile

    JSR NameInput_DrawName      ; Redraw the name as it appears on-screen

    LDA cursor                  ; Then add to our cursor
    CLC
    ADC cursoradd
    STA cursor

    JMP @MainLoop               ; And keep going!

   @Done:
    CLC                 ; CLC to indicate name was successfully input
    RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_Frame  [$9E33 :: 0x39E43]
;;
;;    Does the typical frame stuff for the Party Gen screen
;;  Note the scroll is not reset here, since there is a little bit of drawing
;;  done AFTER this (which is dangerous -- what if the music routine runs long!)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_Frame:
    JSR ClearOAM           ; wipe OAM then draw all sprites
    JSR PtyGen_DrawChars
    JSR PtyGen_DrawCursor

    JSR WaitForVBlank_L    ; VBlank and DMA
    LDA #>oam
    STA $4014

    LDA #BANK_THIS         ; then keep playing music
    STA cur_bank
    JSR CallMusicPlay

    JMP PtyGen_Joy         ; and update joy data!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  CharName_Frame  [$9E4E :: 0x39E5E]
;;
;;    Does typical frame stuff for the Character naming screen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Blinker_LUT:               ; positions for the blinker under letters
.byte $60, $68, $70, $78, $80, $88, $90, $90

CharName_Frame:
    JSR ClearOAM           ; wipe OAM then draw the cursor
    JSR CharName_DrawCursor

    LDA playtimer          ; get the milliseconds (music increments and wraps this)
    CMP #30                ; depending on if its the first or second half of the second, skip displaying the blinker
    BCC :+

    LDX cursor
    LDA Blinker_LUT, X

    LDX sprindex
    STA oam+$3, X          ; upper left horizontal coordinate
    LDA #$22
    STA oam+$0, X          ; upper left vertical coordinate
    LDA #$EF
    STA oam+$1, X          ; graphic: _
    LDA #$01
    STA oam+$2, X          ; attribute

  : JSR WaitForVBlank_L    ; VBlank and DMA
    LDA #>oam
    STA $4014

    LDA soft2000           ; reset the scroll to zero.
    STA $2000
    LDA #0
    STA $2005
    STA $2005

    LDA #BANK_THIS         ; keep playing music
    STA cur_bank
    JSR CallMusicPlay

    ; then update joy by running seamlessly into PtyGen_Joy

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_Joy  [$9E70 :: 0x39E80]
;;
;;    Updates Joypad data and plays button related sound effects for the Party
;;  Generation AND Character Naming screens.  Seems like a huge waste, since sfx could
;;  be easily inserted where the game handles the button presses.  But whatever.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_Joy:
    LDA joy
    AND #$0F
    STA tmp+7            ; put old directional buttons in tmp+7 for now

    JSR UpdateJoy        ; then update joypad data

    LDA joy_a            ; if either A or B pressed...
    ORA joy_b
    BEQ :+
      JMP PlaySFX_MenuSel ; play the Selection SFX, and exit

:   LDA joy              ; otherwise, check new directional buttons
    AND #$0F
    BEQ @Exit            ; if none pressed, exit
    CMP tmp+7            ; if they match the old buttons (no new buttons pressed)
    BEQ @Exit            ;   exit
    JMP PlaySFX_MenuMove ; .. otherwise, play the Move sound effect
  @Exit:
    RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawBoxes  [$9E90 :: 0x39EA0]
;;
;;    Draws the 4 boxes for the Party Generation screen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawBoxes:
    LDA #0
    STA tmp+15       ; reset loop counter to zero

  @Loop:
      JSR @Box       ; then loop 4 times, each time, drawing the next
      LDA tmp+15     ; character's box
      CLC
      ADC #$13       ; incrementing by $13 each time (indexes ptygen buffer)
      STA tmp+15
      CMP #$40      ;; JIGS - this might should be $4C but I guess it doesn't matter
      BCC @Loop
    RTS

 @Box:
    LDX tmp+15           ; get ptygen index in X

    LDA ptygen_box_x, X  ; get X,Y coords from ptygen buffer
    STA box_x
    LDA ptygen_box_y, X
    STA box_y

    LDA #11              ; fixed width/height of 10
    STA box_wd
    STA box_ht

    LDA #0
    STA menustall        ; disable menustalling (PPU is off)
    JMP DrawBox          ;  draw the box, and exit


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawText  [$9EBC :: 0x39ECC]
;;
;;    Draws the text for all 4 character boxes in the Party Generation screen.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawText:
    LDA #0             ; start loop counter at zero
  @MainLoop:
     PHA                ; push loop counter to back it up
     JSR @DrawOne       ; draw one character's strings
     PLA                ;  pull loop counter
     CLC                ; and increase it to point to next character's data
     ADC #$13
     CMP #$4C

     BCC @MainLoop      ;  loop until all 4 chars drawn
    RTS

  @DrawOne:
    TAX                 ; put the ptygen index in X for upcoming routine

    ; no JMP or RTS -- code flows seamlessly into PtyGen_DrawOneText

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawOneText  [$9ECC :: 0x39EDC]
;;
;;    This draws text for *one* of the character boxes in the Party Generation
;;  screen.  This is called by the above routine to draw all 4 of them at once,
;;  but is also called to redraw an individual class name when the player changes
;;  the class of the selected character.
;;
;;    The text drawn here is just two short strings.  First is the name of the
;;  selected class (Fighter/Thief/etc).  Second is the character's name.
;;
;;    Text is drawn by simply copying short strings to the format buffer, then
;;  calling DrawComplexString to draw them.  The character's name is simply
;;  the 4 letters copied over.. whereas the class name makes use of one
;;  of DrawComplexString's control codes.  See that routine for further details.
;;
;;  IN:  X = ptygen index of the char whose text we want to draw
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawOneText:
    LDA ptygen_class_x, X   ; get X,Y coords where we're going to place
    STA dest_x              ;  the class name
    LDA ptygen_class_y, X
    STA dest_y

    LDA ptygen_class, X     ; get the selected class
    CMP #CLASS_TH           ; this silly thing just centers the THIEF text...
    BEQ :+
    CMP #CLASS_NJ           ; and the NINJA if its ever set to print here
    BNE :++

  : INC dest_x

  : CLC
    ADC #ITEM_CLASSSTART    ; add $F0 to select the class' "item name"
    STA format_buf-1        ;  store that as 2nd byte in format string
    LDA #$FF
    STA format_buf-3
    LDA #$02                ; first byte in string is $02 -- the control code to
    STA format_buf-2        ;  print an item name

    LDA #<(format_buf-3)    ; set the text pointer to point to the start of the 2-byte
    STA text_ptr            ;  string we just constructed
    LDA #>(format_buf-3)
    STA text_ptr+1

    LDA #BANK_THIS          ; set cur and ret banks (see DrawComplexString for why)
    STA cur_bank
    STA ret_bank

    TXA                     ; back up our index (DrawComplexString will corrupt it)
    PHA
    JSR DrawComplexString   ; draw the string
    PLA
    TAX                     ; and restore our index

    LDA ptygen_name, X
    STA format_buf-7
    LDA ptygen_name+1, X
    STA format_buf-6
    LDA ptygen_name+2, X
    STA format_buf-5
    LDA ptygen_name+3, X
    STA format_buf-4
    LDA ptygen_name+4, X
    STA format_buf-3
    LDA ptygen_name+5, X
    STA format_buf-2
    LDA ptygen_name+6, X
    STA format_buf-1

    LDA ptygen_name_x, X    ; set destination coords appropriately
    STA dest_x
    LDA ptygen_name_y, X
    STA dest_y

    ;; JIGS - for longer names

    LDA #<(format_buf-7)    ; set pointer to start of 4-byte string
    STA text_ptr
    LDA #>(format_buf-7)
    STA text_ptr+1

    LDA #BANK_THIS          ; set banks again (not necessary as they haven't changed from above
    STA cur_bank            ;   but oh well)
    STA ret_bank

    JMP DrawComplexString   ; then draw another complex string -- and exit!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawCursor  [$9F26 :: 0x39F36]
;;
;;    Draws the cursor for the Party Generation screen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawCursor:
    LDX char_index          ; use the current index to get the cursor
    LDA ptygen_curs_x, X    ;  coords from the ptygen buffer.
    STA spr_x
    LDA ptygen_curs_y, X
    STA spr_y
    JMP DrawCursor          ; and draw the cursor there



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  CharName_DrawCursor  [$9F35 :: 0x39F45]
;;
;;    Draws the cursor for the Character Naming screen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CharName_DrawCursor:
    LDA cursor_x      ; X position = (cursx * 16) + $20
    ASL A
    ASL A
    ASL A
    ASL A
    CLC
    ADC #$20
    STA spr_x

    LDA cursor_y      ; Y position = (cursy * 16) + $50
    ASL A
    ASL A
    ASL A
    ASL A
    CLC
    ADC #$50
    STA spr_y

    JMP DrawCursor


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  PtyGen_DrawChars  [$9F4E :: 0x39F5E]
;;
;;    Draws the sprites for all 4 characters on the party gen screen.
;;  This routine uses DrawSimple2x3Sprite to draw the sprites.
;;  See that routine for details.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PtyGen_DrawChars:
    LDX #$00         ; Simply call @DrawOne four times, each time
    JSR @DrawOne     ;  having the index of the char to draw in X
    LDX #$13
    ;; JIGS ^ again, increase by 3 for every character
    JSR @DrawOne
    LDX #$26
    JSR @DrawOne
    LDX #$39


  @DrawOne:
    LDA ptygen_spr_x, X   ; load desired X,Y coords for the sprite
    STA spr_x
    LDA ptygen_spr_y, X
    STA spr_y

    ;LDA ptygen_class, X   ; get the class
    LDA ptygen_sprite, X   ; JIGS - get the SPRITE
    TAX
    LDA lutClassBatSprPalette, X   ; get the palette that class uses
    STA tmp+1             ; write the palette to tmp+1  (used by DrawSimple2x3Sprite)

    TXA               ; multiply the class index by $06
    ASL A             ; double it
	STA tmp           ; save it
	ASL A             ; double it again
	CLC               ; add in the first double!
	ADC tmp
    STA tmp           ; store it in tmp for DrawSimple2x3Sprite
    JMP DrawSimple2x3Sprite



;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  NameInput_DrawName  [$9F7D :: 0x39F8D]
;;
;;    Used during party generation.. specifically the name input screen
;;  to draw the character's name at the top of the screen.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NameInput_DrawName:
            @buf  = $59 ; $5C     ; local - buffer to hold the name for printing
            ;; JIGS ^ move the buffer further in, but its okay! Not overwriting anything. I think.

    LDX char_index          ; copy the character's name to our temp @buf
    LDA ptygen_name, X
    STA @buf
    LDA ptygen_name+1, X
    STA @buf+1
    LDA ptygen_name+2, X
    STA @buf+2
    LDA ptygen_name+3, X
    STA @buf+3              ; The code assumes @buf+4 is 0
    ;; JIGS - adding more letters ^ this is still correct, but 7 instead of 4
    LDA ptygen_name+4, X
    STA @buf+4
    LDA ptygen_name+5, X
    STA @buf+5
    LDA ptygen_name+6, X
    STA @buf+6

    LDA #>@buf              ; Set the text pointer
    STA text_ptr+1
    LDA #<@buf
    STA text_ptr

    LDA #BANK_THIS          ; set cur/ret banks
    STA cur_bank
    STA ret_bank

    LDA #$0C                ; set X/Y positions for the name to be printed
    STA dest_x
    LDA #$04
    STA dest_y

    LDA #$01                ; drawing while PPU is on, so set menustall
    STA menustall

    JMP DrawComplexString   ; Then draw the name and exit!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  DrawNameInputScreen  [$9FB0 :: 0x39FC0]
;;
;;  Draws everything except for the player's name.
;;
;;  Assumes PPU is off upon entry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DrawNameInputScreen:
    LDA $2002               ; clear PPU toggle

;    LDA #>$23C0             ; set PPU addr to the attribute table
;    STA $2006
;    LDA #<$23C0
;    STA $2006

;    LDA #$00                ; set $10 bytes of the attribute table to use palette 0
;    LDX #$10                ;  $10 bytes = 8 rows of tiles (32 pixels)
;    : STA $2007             ; This makes the top box the orangish color instead of the normal blue
;      DEX
;      BNE :-

;; JIGS - not doing that anymore!

    LDA #0
    STA menustall           ; no menustall (PPU is off at this point)

    LDA #$04                ; Draw the big box containing input
    STA box_x
    LDA #$08
    STA box_y
    LDA #$17
    STA box_wd
    LDA #$14
    STA box_ht
    JSR DrawBox

    LDA #$0A               ; Draw the small top box containing the player's name
    STA box_x
    LDA #$02
    STA box_y
    LDA #$0B ; 06
    STA box_wd
    LDA #$05 ; 04
    STA box_ht
    JSR DrawBox

    LDA #<lut_NameInput     ; Print the NameInput lut as a string.  This will fill
    STA text_ptr            ;  the bottom box with the characters the user can select.
    LDA #>lut_NameInput
    STA text_ptr+1
    LDA #$06
    STA dest_x
    LDA #$0A
    STA dest_y
    LDA #BANK_THIS
    STA cur_bank
    STA ret_bank
    JMP DrawComplexString


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Name Input Row Start lut  [$A00A :: 0x3A01A]
;;
;;    offset (in usable characters) to start of each row in the below lut_NameInput

lut_NameInputRowStart:
  .BYTE  0, 10, 20, 30, 40, 50, 60  ; 10 characters of data per row
                                    ;  (which is actually 20 bytes, because they have spaces between them)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Name Input lut  [$A011 :: 0x3A021]
;;
;;    This lut is not only used to get the character the user selection on the name input screen,
;;  but it also is stored in null-terminated string form so that the entire thing can be drawn with
;;  with a single call to DrawComplexString.  It's intersperced with $FF (spaces) and $01 (double line breaks)

lut_NameInput:
  .BYTE $8A, $FF, $8B, $FF, $8C, $FF, $8D, $FF, $8E, $FF, $8F, $FF, $90, $FF, $91, $FF, $92, $FF, $93, $01  ; A - J
  .BYTE $94, $FF, $95, $FF, $96, $FF, $97, $FF, $98, $FF, $99, $FF, $9A, $FF, $9B, $FF, $9C, $FF, $9D, $01  ; K - T
  .BYTE $9E, $FF, $9F, $FF, $A0, $FF, $A1, $FF, $A2, $FF, $A3, $FF, $BE, $FF, $BF, $FF, $C0, $FF, $FF, $01  ; U - Z ; , . <space>
  .BYTE $80, $FF, $81, $FF, $82, $FF, $83, $FF, $84, $FF, $85, $FF, $86, $FF, $87, $FF, $88, $FF, $89, $01  ; 0 - 9
  .BYTE $A4, $FF, $A5, $FF, $A6, $FF, $A7, $FF, $A8, $FF, $A9, $FF, $AA, $FF, $AB, $FF, $AC, $FF, $AD, $01  ; a - j
  .BYTE $AE, $FF, $AF, $FF, $B0, $FF, $B1, $FF, $B2, $FF, $B3, $FF, $B4, $FF, $B5, $FF, $B6, $FF, $B7, $01  ; k - t
  .BYTE $B8, $FF, $B9, $FF, $BA, $FF, $BB, $FF, $BC, $FF, $BD, $FF, $C2, $FF, $C3, $FF, $C4, $FF, $C5, $01  ; u - z - .. ! ?
  ;.BYTE $01
  ;.BYTE $FF, $FF, $FF, $9C, $8E, $95, $8E, $8C, $9D, $FF, $FF, $97, $8A, $96, $8E, $00                      ;   SELECT  NAME

  ;; JIGS - I think this looks nicer:

  .BYTE $05
  .BYTE $97,$8A,$96,$8E,$FF,$A2,$98,$9E,$9B,$FF,$8C,$91,$8A,$9B,$8A,$8C,$9D,$8E,$9B,$00 ; NAME YOUR CHARACTER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  LUT for party generation  [$A0AE :: 0x3A0BE]
;;
;;    This LUT is copied to the RAM buffer 'ptygen' which is used to
;;  track which class is selected for each character, what their name is,
;;  where they're to be drawn, etc.  This can be changed to assign a default
;;  party or default names, and to rearrange some of the graphics for the
;;  Party Generation Screen
;;
;;    See details of 'ptygen' buffer in RAM for a full understanding of
;;  the format of this table.

lut_PtyGenBuf:
;  .BYTE $00,$00,$FF,$FF,$FF,$FF,$07,$0C,$05,$06,$40,$40,$04,$04,$30,$40
;  .BYTE $01,$00,$FF,$FF,$FF,$FF,$15,$0C,$13,$06,$B0,$40,$12,$04,$A0,$40
;  .BYTE $02,$00,$FF,$FF,$FF,$FF,$07,$18,$05,$12,$40,$A0,$04,$10,$30,$A0
;  .BYTE $03,$00,$FF,$FF,$FF,$FF,$15,$18,$13,$12,$B0,$A0,$12,$10,$A0,$A0

  ;      1   2                           3   4   5   6   7   8   9   10  11  12  13
  .BYTE $00,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$06,$0A,$05,$04,$48,$30,$04,$02,$33,$34,$00
  .BYTE $01,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$13,$0A,$12,$04,$B0,$30,$11,$02,$9C,$34,$01
  .BYTE $02,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$06,$16,$05,$10,$48,$90,$04,$0E,$33,$94,$02
  .BYTE $03,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$13,$16,$12,$10,$B0,$90,$11,$0E,$9C,$94,$03

  ;; JIGS ^ adding 3 more bytes for names, and one for sprite instead of class... ^
; 1 - ptygen_class   
; 2 - ptygen_name    
; 3 - ptygen_name_x  
; 4 - ptygen_name_y  
; 5 - ptygen_class_x 
; 6 - ptygen_class_y 
; 7 - ptygen_spr_x   
; 8 - ptygen_spr_y   
; 9 - ptygen_box_x   
; 10 - ptygen_box_y  
; 11 - ptygen_curs_x 
; 12 - ptygen_curs_y 
; 13 - ptygen_sprite 


lut_ClassStartingStats:
;     HP   Str  Agil Int  Vit  Luck DMG  Hit% Evade MDef  MP   Weapon Armor Spell  
.byte $23, $14, $05, $01, $0A, $05, $0A, $0A, $35,  $0F,  $00, $02,   $41,  $00 ; Fighter ; 0
.byte $1E, $05, $0A, $05, $05, $0F, $02, $05, $3A,  $0F,  $00, $02,   $41,  $00 ; Thief   ; 1
.byte $21, $05, $05, $05, $14, $05, $02, $05, $35,  $0A,  $00, $00,   $41,  $00 ; BB      ; 2
.byte $1E, $0A, $0A, $0A, $05, $05, $05, $07, $3A,  $14,  $22, $03,   $41,  $00 ; RedMage ; 3
.byte $1C, $05, $05, $0F, $0A, $05, $02, $05, $35,  $14,  $22, $03,   $41,  $00 ; WMage   ; 4
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; BMage   ; 5
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 6
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 7
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 8
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 9
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 10
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 11
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 12
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 13
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 14
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 15
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 16
.byte $23, $14, $05, $01, $0A, $05, $0A, $0A, $35,  $0F,  $00, $02,   $41,  $00 ; Knight  ; 17
.byte $1E, $05, $0A, $05, $05, $0F, $02, $05, $3A,  $0F,  $00, $02,   $41,  $00 ; Ninja   ; 18
.byte $21, $05, $05, $05, $14, $05, $02, $05, $35,  $0A,  $00, $00,   $41,  $00 ; Master  ; 19
.byte $1E, $0A, $0A, $0A, $05, $05, $05, $07, $3A,  $14,  $22, $03,   $41,  $00 ; RedWiz  ; 20
.byte $1C, $05, $05, $0F, $0A, $05, $02, $05, $35,  $14,  $22, $03,   $41,  $00 ; WWiz    ; 21
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Bwiz    ; 22
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 23
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 24
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 25
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 26
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 27
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 28
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 29
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 30
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 31
.byte $19, $01, $0A, $14, $01, $0A, $01, $05, $3A,  $14,  $22, $03,   $41,  $00 ; Unused  ; 32
;                                                                     \ 02 small knife or 03 wooden staff
;                                                                            \ 01 cloth armour

lut_InitUnsramFirstPage:
.byte %01010000 ; 00 overworld flags
.byte $D2 ; 01 ship X 
.byte $99 ; 02 ship Y
.byte $DD ; 03 airship X
.byte $ED ; 04 airship Y
.byte $98 ; 05 bridge X
.byte $98 ; 06 bridge Y
.byte $66 ; 07 canal X
.byte $A4 ; 08 canal Y
.byte $00 ; 09 ow2_vehicle X
.byte $00 ; 0A ow2_vehicle Y
.byte $00 ; 0B overworld 2 scroll x
.byte $00 ; 0C overworld 2 scroll y
.byte $92 ; 0D overworld scroll x
.byte $9E ; 0E overworld scroll y
.byte $01 ; 0F overworld vehicle

.byte %00000001 ; 10 options - only auto target on
.byte $04 ; 11 battle text speed (5)
.byte $00 ; 12 battle text background color (0: blue)
.byte $00 ; 13 smokebomb steps
.byte $00 ; 14 battles won
.byte $00 ; 15 battles fled
.byte $90 ; 16 gold low
.byte $01 ; 17 gold middle
.byte $00 ; 18 gold high
.byte $00 ; 19 play time 
.byte $00 ; 1A
.byte $00 ; 1B
.byte $00 ; 1C
.byte $00 ; 1D checksum stuff
.byte $00 ; 1E
.byte $00 ; 1F

; Items
.byte $00 ; 20 unused
.byte $02 ; 21 heal -- JIGS - added two heals
.byte $00 ; 22 X-heal
.byte $00 ; 23 ether
.byte $00 ; 24 elixier
.byte $01 ; 25 pure -- JIGS - added one pure 
.byte $00 ; 26 soft
.byte $00 ; 27 phoenix down
.byte $00 ; 28 tent
.byte $00 ; 29 cabin
.byte $00 ; 2A house
.byte $00 ; 2B eyedrops
.byte $00 ; 2C smokebomb
.byte $00 ; 2D wakeup bell
.byte $00 ; 2E nothing
.byte $00 ; 2F nothing

; Key Items
.byte $00 ; 30 key items 1
.byte $00 ; 31 key items 2
.byte $00 ; 32 key items 3
.byte $00 ; 33 key items 4
.byte $00 ; 34 
.byte $00 ; 35
.byte $00 ; 36
.byte $00 ; 37
.byte $00 ; 38
.byte $00 ; 39
.byte $00 ; 3A
.byte $00 ; 3B
.byte $00 ; 3C fire orb
.byte $00 ; 3D water orb
.byte $00 ; 3E air orb 
.byte $00 ; 3F earth orb


DrawOptions:
    LDA #24
    STA dest_x
    LDA #8
    STA dest_y
    LDX ExpGainOption
    LDA lut_LowNormalHigh, X
    JSR DrawZ_MenuString
    
    LDA #10
    STA dest_y
    LDX MoneyGainOption
    LDA lut_LowNormalHigh, X
    JSR DrawZ_MenuString

    LDA #12
    STA dest_y
    LDX EncRateOption    
    LDA lut_LowNormalHigh, X
    JSR DrawZ_MenuString

    JSR LongCall
    .word BattleBGColorDigits
    .byte BANK_MENUS
    
    LDA $2002          ; PPU toggle... needed or not?
    LDA #>$221A        ; Color is drawn here
    STA $2006
    LDA #<$221A
    STA $2006
    LDA format_buf-2
    STA $2007
    LDA format_buf-1
    STA $2007
    
    LDA #>$21DB        ; Respond rate is drawn here
    STA $2006
    LDA #<$21DB
    STA $2006
    LDA BattleTextSpeed ; get the current respond rate (which is zero based)
    CLC                 ;  add $80+1 to it.  $80 to convert it to the coresponding tile
    ADC #$80+1          ;  for the desired digit to print, and +1 to convert it from zero
    STA $2007           ;  based to 1 based (so it's printed as 1-8 instead of 0-7)
    LDA #$00            ; reset scroll to 0 (very important!)
    STA $2005
    STA $2005
    
    LDA #24
    STA dest_x
    LDA #18
    STA dest_y
    LDX AutoTargetOption
    LDA lut_OnOff, X
    JSR DrawZ_MenuString
    
    LDA #20
    STA dest_y
    LDX MuteSFXOption
    LDA lut_OnOff, X
    JMP DrawZ_MenuString


SaveOptions:
    LDA AutoTargetOption
    STA Options
    LDA MuteSFXOption
    ASL A
    JSR @QuickSave
    LDA ExpGainOption
    ASL A
    ASL A
    JSR @QuickSave
    LDA MoneyGainOption
    ASL A
    ASL A
    ASL A
    ASL A
    JSR @QuickSave
    LDA EncRateOption
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A
    
   @QuickSave:    
    ORA Options
    STA Options
    RTS 

OptionsMenu:
    JSR ClearButtons          ; A = 0
    STA cursor
    STA joy_prevdir        ; as well as resetting the cursor and previous joy direction
    STA $2001
    STA menustall

    LDX BattleBGColor
    LDA BattleBackgroundColor_LUT, X
    STA cur_pal+14

    LDA #1
    STA box_x
    LDA #6
    STA box_y
    LDA #30
    STA box_wd
    LDA #17
    STA box_ht
    JSR DrawBox                ; draws the options box

    LDA #7
    STA cursor_max
    LDA #0
    JSR DrawZ_MenuString       ; draws the static list of changable things
    
    LDA Options
    AND #AUTO_TARGET
    STA AutoTargetOption
    LDA Options
    AND #SFX_MUTED
    LSR A
    STA MuteSFXOption
    LDA Options
    AND #EXP_GAIN_LOW | EXP_GAIN_HIGH
    LSR A
    LSR A
    STA ExpGainOption
    LDA Options
    AND #MONEY_GAIN_LOW | MONEY_GAIN_HIGH
    LSR A
    LSR A
    LSR A
    LSR A    
    STA MoneyGainOption
    LDA Options
    AND #ENC_RATE_LOW | ENC_RATE_HIGH
    LSR A
    LSR A    
    LSR A
    LSR A
    LSR A
    LSR A
    STA EncRateOption
    
    JSR TurnMenuScreenOn_ClearOAM

ReenterOptionsMenu:
    LDA #1
    STA menustall              ; turn menustall back on
    JSR DrawOptions            ; and draw the option variables (off, on, high, low, etc)

OptionsLoop:
    JSR ClearOAM
    JSR DrawOptionsCursor        ; draw the cursor
    JSR MenuFrame                ; Do a frame
    
    LDA joy_a                    ; check to see if A has been pressed
    BNE @A_Pressed
    LDA joy_b                    ; then see if B has been pressed
    BNE @B_Pressed
    JSR @OptionDirections
    JMP OptionsLoop

  @B_Pressed:
    JMP SaveOptions

  @A_Pressed:
    LDA #0                  ; enter ChangeOption with A = 0, as if right was pressed
    JSR ChangeOption
    ;PLA
    ;PLA
    JMP ReenterOptionsMenu

  @OptionDirections:
    LDA joy                 ; mask out the directional buttons from the joy data
    AND #$0F
    CMP joy_prevdir         ; see if the state of any directional buttons changed
    BEQ @Return             ; if not, keep looping

    STA joy_prevdir         ; otherwise, record changes to direction
    CMP #0                  ; see if the change was buttons being pressed or lifted
    BEQ @Return             ; if buttons were being lifted, do nothing (keep looping)

    CMP #$03                ; see if they pressed up/down or left/right
    BCC @LeftRight

  @UpDown:
    CMP #DOWN
    BNE @Up

   @Down:              ; moving down...
    LDA cursor         ;  get cursor, and increment by 1
    CLC
    ADC #$01
    CMP cursor_max    ;  if it's < cursor_max, it's still in range, so
    BCC @Move         ;   jump ahead to move
    LDA #0            ;  otherwise, it needs to be wrapped to zero
    BEQ @Move         ;   (always branches)

   @Up:               ; up is the same deal...
    LDA cursor        ;  get cursor, decrement by 1
    SEC
    SBC #$01
    BPL @Move         ; if the result didn't wrap (still positive), jump ahead to move
    LDA cursor_max    ;  otherwise wrap so that it equals cursor_max-1
    SEC
    SBC #$01

   @Move:
    STA cursor            ; set cursor to changed value
    JMP PlaySFX_MenuMove  ; then play that hideous sound effect and exit

   @Return:
    RTS

   @LeftRight:
    CMP #RIGHT
    BEQ :+
      LDA #1              ; enter ChangeOption with A = 1 if left was pressed
      BNE :++

  : LDA #0                ; enter ChangeOption with A = 0 if right was pressed
  : JSR ChangeOption
    PLA
    PLA
    JMP ReenterOptionsMenu

ChangeOption:
    PHA                   ; backup direction
    JSR PlaySFX_MenuSel
    LDA cursor
    BEQ @ExpGain
    CMP #1
    BEQ @JMP_MoneyGain
    CMP #2
    BEQ @JMP_EncounterRate
    CMP #3
    BEQ @BattleTextSpeed
    CMP #4
    BEQ @JMP_BattleBackground
    CMP #5
    BEQ @JMP_AutoTarget
    PLA                   ; pull direction and toss it

   @MenuSFX:
    LDA MuteSFXOption     ; whether left or right is pressed, all you can do is switch it on/off
    BEQ :+
      DEC MuteSFXOption
      BEQ :++

  : INC MuteSFXOption
  : JMP SaveOptions       ; update this one instantly

   @JMP_BattleBackground:
    JMP BattleBackgroundColor

   @JMP_MoneyGain:
    JMP @MoneyGain

   @JMP_EncounterRate:
    JMP @EncounterRate

   @BattleTextSpeed:
    PLA                     ; pull direction and branch
    BEQ @IncreaseBattleTextSpeed

       DEC BattleTextSpeed
       LDA BattleTextSpeed
       BPL @Return         ; if the result didn't wrap (still positive), return
       LDA #8
       STA BattleTextSpeed
       RTS

   @IncreaseBattleTextSpeed:
    LDA BattleTextSpeed
    CMP #8
    BNE :+                  ; if its not over the limit, increase it
       LDA #0
       STA BattleTextSpeed
       RTS

  : INC BattleTextSpeed
   @Return:
    RTS

   @JMP_AutoTarget:
    JMP @AutoTarget

   @ExpGain:
    PLA
    BEQ @IncreaseExpGain

       DEC ExpGainOption
       LDA ExpGainOption
       BPL @Return         ; if the result didn't wrap (still positive), return
       LDA #2
       STA ExpGainOption
       RTS

   @IncreaseExpGain:
    LDA ExpGainOption
    CMP #2
    BNE :+                  ; if its not over the limit, increase it
       LDA #0
       STA ExpGainOption
       RTS

  : INC ExpGainOption
    RTS

   @MoneyGain:
    PLA
    BEQ @IncreaseMoneyGain

       DEC MoneyGainOption
       LDA MoneyGainOption
       BPL @Return         ; if the result didn't wrap (still positive), return
       LDA #2
       STA MoneyGainOption
       RTS

   @IncreaseMoneyGain:
    LDA MoneyGainOption
    CMP #2
    BNE :+                  ; if its not over the limit, increase it
       LDA #0
       STA MoneyGainOption
       RTS

  : INC MoneyGainOption
    RTS

   @EncounterRate:
    PLA
    BEQ @IncreaseEncounterRate

       DEC EncRateOption
       LDA EncRateOption
       BPL @Return         ; if the result didn't wrap (still positive), return
       LDA #2
       STA EncRateOption
       RTS

   @IncreaseEncounterRate:
    LDA EncRateOption
    CMP #2
    BNE :+                  ; if its not over the limit, increase it
       LDA #0
       STA EncRateOption
       RTS

  : INC EncRateOption
    RTS

   @AutoTarget:
    PLA                      ; pull direction and toss it
    LDA AutoTargetOption     ; whether left or right is pressed, all you can do is switch it on/off
    BEQ :+
      DEC AutoTargetOption
      RTS

  : INC AutoTargetOption
    RTS


BattleBackgroundColor:
    PLA
    BEQ @NextColor

   @PreviousColor:
    DEC BattleBGColor
    JMP @Return 

   @NextColor:
    INC BattleBGColor

   @Return:
    LDA BattleBGColor
    AND #$0F
    TAX
    STX BattleBGColor
    LDA BattleBackgroundColor_LUT, X
    STA cur_pal+14
    JMP TurnOnScreen


DrawOptionsCursor:
    LDY cursor                   ; get current cursor selection
    LDA lut_OptionsCursor_Y, Y   ;  use cursor as an index to get the desired Y coord
    STA spr_y                    ;  write the Y coord
    LDA #$B0                     ; X coord for options menu cursor is always 22
    STA spr_x
    JMP DrawCursor               ; draw it!  and exit

lut_OptionsCursor_Y:
   .BYTE  $40,$50,$60,$70,$80,$90,$A0







SoundTestClearNT:
    JSR ClearNT

    LDX #>$23C0
    LDA #<$23C0
    STX $2006   ; write X as high byte
    STA $2006   ; A as low byte

    LDA #0
    LDX #$10
   @Loop1:
    STA $2007
    DEX
    BNE @Loop1

    LDA #$F0
    LDX #$8
   @Loop2:
    STA $2007
    DEX
    BNE @Loop2

    LDA #$FF
    LDX #$28
   @Loop3:
    STA $2007
    DEX
    BNE @Loop3
    RTS

;; that should set the attributes to look like this:
;  .BYTE $00,$00,$00,$00,$00,$00,$00,$00
;  .BYTE $00,$00,$00,$00,$00,$00,$00,$00
;  .BYTE $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0
;  .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
;  .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
;  .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
;  .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
;  .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF




SoundTestPalette:
    .byte $0F, $38, $36, $17
    .byte $0F, $07, $17, $0F
    .byte $0F, $00, $10, $30

SoundTestZ:
    LDA #BANK_THIS           ; record current bank and CallMusicPlay
    STA cur_bank
    
    LDA #0
    STA cursor
    STA soundtest_track
    STA weasels
    STA joy
    STA joy_prevdir

    JSR SoundTestClearNT     ; clear the nametable, set the attributes, load weasel sprite
    STX menustall            ; X = 0

    
    LDA #$50
    STA btlattackspr_gfx     ; to load up the weasel and hole

    LDA #$02
    STA MMC5_tmp             ; set to load 8 tiles of magic attack sprites

    JSR LongCall
    .word LoadSprite_Bank03
    .byte $03

    LDA #$02
    STA box_x
    LDA #$0A
    STA box_y
    LDA #$1C
    STA box_wd
    LDA #$05
    STA box_ht
    JSR DrawBox              ; draw the song name box

    LDA #$02
    STA box_x
    LDA #$14
    STA box_y
    LDA #$1C
    STA box_wd
    LDA #$08
    STA box_ht
    JSR DrawBox              ; draw the instructions box

    INC dest_x
    LDA #$0C
    JSR DrawZ_MenuString            ; draw the instructions

   ; Weasel colours!
    LDX #12
  : LDA SoundTestPalette, X
    STA cur_pal+$14, X
    DEX
    BPL :-

    STA cur_pal+2
    LDA #$20
    STA cur_pal+3

    JSR TurnMenuScreenOn_ClearOAM   ; then clear OAM and turn the screen on

SoundTest_NewSong:
    LDA #1
    STA menustall         ; enable to write while PPU is on
    LDA #$05
    STA dest_x
    LDA #$0C
    STA dest_y
    LDA soundtest_track   ; 0-24, or however many songs there are
    CLC
    ADC #$10              ; all song names are after $10 in the lut_ZMenuText table
    JSR DrawZ_MenuString

SoundTestMenuLoop:
    JSR ClearOAM                  ; clear OAM (erasing    all existing sprites)
    JSR DrawSoundTestCursor       ; draw the cursor
    JSR DrawSoundTestHole
    JSR WeaselSprite
    JSR SoundTestFrame            ; Do a frame

    LDA joy_a                     ; check to see if A has been pressed
    BNE @A_Pressed
    LDA joy_b                     ; then see if B has been pressed
    BNE @B_Pressed
    LDA joy_start
    BNE @Start_Pressed
    LDA joy_select
    BNE @Zoom
    JSR SoundTestSelect
    BCC SoundTest_NewSong         ; carry set if new song chosen (only prints text, doesn't update music)
    JMP SoundTestMenuLoop         ; rinse, repeat

   @B_Pressed:
    JSR ClearOAM             ; clear OAM
    JSR ClearButtons
    STA joy_prevdir          ; as well as resetting the cursor and previous joy direction
    STA $2001
    STA $4015                ; and silence the APU.  Music sill start next time MusicPlay is called.
    STA $5015                ; and silence the MMC5 APU.
    STA dlgmusic_backup
    STA soundtest_track
    RTS                      ; and exit the main menu (by RTSing out of its loop)

   @A_Pressed:
    LDA soundtest_track    
    BPL @TurnMusicOn         ; if the high bit is set, current track is playing
      AND #$7F               ; so shut it off
      STA soundtest_track
      LDA #0
      STA $4015              ; silence APU
      STA $5015              ; and silence the MMC5 APU. (JIGS)
      JMP SoundTestMenuLoop  ; then return to main menu loop

   @TurnMusicOn:
    PHA
    ORA #$80
    STA soundtest_track      ; set high bit to indicate music is now playing
    LDA #0
    STA $4015                ; silence APU
    STA $5015                ; and silence the MMC5 APU. (JIGS)
    JSR WaitForVBlank_L
    PLA
    CLC
    ADC #$41
    STA music_track
    JMP SoundTestMenuLoop     ; then return to main menu loop

   @Start_Pressed:
    JSR DrawZheepText
    JMP SoundTestMenuLoop

   @Zoom:
    JSR WeaselZoomStart
    JMP SoundTestMenuLoop

SoundTestFrame:
    JSR WaitForVBlank_L    ; wait for VBlank
    LDA #>oam              ; Do sprite DMA (update the 'real' OAM)
    STA $4014

    LDA soft2000           ; reset scroll and PPU data
    STA $2000
    LDA #0
    STA $2005
    STA $2005

    LDA #BANK_THIS         ; record current bank and CallMusicPlay
    STA cur_bank
    JSR CallMusicPlay

    LDA playtimer          ; pause the play timer while in the sound test!
    CMP #59                ; but if its about to hit 60, don't touch it
    BEQ :+                 ; or else every frame here will count as a second for total playtime
        DEC playtimer

  : JSR ClearButtons
    JMP UpdateJoy          ; update joypad info, then exit

SoundTestSelect:
    LDA joy           ; get joypad data
    AND #$0C          ;  isolate up/down buttons
    CMP joy_prevdir   ;  compare it to previously checked button states
    BEQ @Exit         ; if they equal, do nothing (button has already been pressed and is currently just held)

    STA joy_prevdir   ; otherwise, button state has changed, so record new button state in prevdir
    CMP #$00          ;  and check to see if a button is being pressed or released (nonzero=pressed)
    BEQ @Exit         ;  if zero, button is being released, so do nothing and just exit

    CMP #$04          ; see if the user pressed down or up
    BNE @Up

   @Down:             ; moving down...
    LDA soundtest_track
    AND #$7F         
    BNE @DecreaseTrack
      LDA #MAX_SONG
      BNE @SetTrack
   
   @DecreaseTrack:
    SEC
    SBC #1
  
   @SetTrack:  
    STA soundtest_track
    CLC
    RTS

   @Up:               ; up is the same deal...
    LDA soundtest_track
    AND #$7F    
    CMP #MAX_SONG
    BNE @IncreaseTrack
       LDA #$FF

   @IncreaseTrack:    
    CLC
    ADC #1
    JMP @SetTrack         ; JMP, because it can be 0 

   @Exit:
    SEC
    RTS

DrawSoundTestCursor:
    LDA #$16
    STA spr_x              ; set cursor X coord to $58
    LDA #$60
    STA spr_y              ; and that's the cursor Y coord
    JMP DrawCursor         ; draw the cursor and exit

DrawSoundTestHole:
    LDA #$08
    STA spr_x              ; set cursor X coord to $58
    LDA #$83
    STA spr_y              ; and that's the cursor Y coord
    LDA #<lutHole          ; load up the pointer to the hole sprite
    STA tmp                ; arrangement
    LDA #>lutHole          ; and store that pointer in (tmp)
    STA tmp+1
    LDA #$34               ; hole tiles start at $DC
    STA tmp+2
    JMP Draw2x2Sprite

DrawZheepText:
    LDA #$01
    STA menustall
    LDX #$1B
    JSR RandAX
    STA dest_x
    LDA #$02
    LDX #$08
    JSR RandAX
    STA dest_y
    DEC weasels
    LDA #$0D
    JMP DrawZ_MenuString

WeaselSprite:
    LDA weasels
    CMP #$F0          ; if less than 9, stop drawing weasels (oawoo)
    BCS @Yes
      LDA #0
      STA weasels
      RTS

   @Yes:
    LDX #$0F
    JSR MultiplyXA

WeaselSpriteZoom:
    STA spr_x
    LDA #$83
    STA spr_y
    LDA #<lutWeasel   ; load up the pointer to the weasel sprite
    STA tmp           ; arrangement
    LDA #>lutWeasel   ; and store that pointer in (tmp)
    STA tmp+1
    LDA #$30          ; weasel tiles start at $00
    STA tmp+2
    JMP Draw2x2Sprite

lutWeasel:
   .BYTE $00, $01      ; UL sprite = tile 0, palette 3
   .BYTE $02, $01      ; DL sprite = tile 2, palette 3
   .BYTE $01, $01      ; UR sprite = tile 1, palette 3
   .BYTE $03, $01      ; DR sprite = tile 3, palette 3

lutHole:
   .BYTE $00, $02      ; UL sprite = tile 0, palette 3
   .BYTE $02, $02      ; DL sprite = tile 2, palette 3
   .BYTE $01, $02      ; UR sprite = tile 1, palette 3
   .BYTE $03, $02      ; DR sprite = tile 3, palette 3


WeaselZoomStart:
   LDA weasels              ; load variable "weasels"; if the weasel is on screen, this will be anything but 0
   BNE WeaselZoomBegin      ; if "weasels" is NOT 0, weasel is printed, so skip ahead to set it in motion
     LDA #245               ; if "weasels" is 0, weasel has not been printed yet; so load 245
     STA weasels            ; and save as "weasels", to start printing on the right side of the screen
     JMP WeaselZoomFrame

WeaselZoom:
   DEC weasels
   DEC weasels
   DEC weasels
   LDA weasels
   CMP #9                   ; if less than 9, stop drawing weasels (oawoo)
   BCS WeaselZoomFrame
       LDA #0
       STA weasels
       RTS

WeaselZoomBegin:
   LDA spr_x
   STA weasels

WeaselZoomFrame:
   JSR WeaselSpriteZoom
   JSR DrawSoundTestCursor       ; draw the cursor
   JSR DrawSoundTestHole
   JSR WaitForVBlank_L    ; wait for VBlank
   LDA #>oam              ; Do sprite DMA (update the 'real' OAM)
   STA $4014

   LDA soft2000           ; reset scroll and PPU data
   STA $2000
   LDA #0
   STA $2005
   STA $2005
   JSR CallMusicPlay
   JSR ClearOAM                  ; clear OAM (erasing all existing sprites)
   JMP WeaselZoom

WeaselChr:
  .INCBIN "chr/weasel.chr"












































;; JIGS - here is all the 3 Save File things.


SaveScreen_FromMenu:
    JSR SaveScreenHelper

SaveScreen:
	JSR LoadBorderPalette_Blue
    LDA #0
    STA $2001
    STA cursor               ; flush cursor, joypad, and prev joy directions
    STA joy
    STA joy_prevdir
    STA menustall            ; disable menu stalling
    STA SaveGameMusic        ; clear this variable, which will help reset music later
    JSR ClearNT              ; clear the NT
    LDA #1
    STA $5113                ; swap battery-backed PRG RAM

    LDA #1
    STA box_x
    LDA #4
    STA box_y
    LDA #30
    STA box_wd
    LDA #8
    STA box_ht
    JSR DrawBox             ; Draw Save Slot Box 1
    LDA #12
    STA box_y
    JSR DrawBox             ; Draw Save Slot Box 2
    LDA #20
    STA box_y
    JSR DrawBox             ; Draw Save Slot Box 3
    LDA #8
    STA box_x
    LDA #1
    STA box_y
    LDA #16
    STA box_wd
    LDA #3
    STA box_ht
    JSR DrawBox             ; Draw Save/Load title box

    LDA #07
    STA dest_y
    LDA #04
    STA dest_x
    LDA #02
    STA cursor_max          ; and Cursor max!
    LDA #$06
    JSR DrawZ_MenuString ; Draw Save slot text: SAVE 1, SAVE 2, SAVE 3
    JSR DrawSaveScreenNames
    LDA weasels
    BNE SaveGameStuff

LoadGameStuff:
    JSR SaveScreenTitleTextPosition
    LDA #$07
    JSR DrawZ_MenuString
    JSR TurnMenuScreenOn_ClearOAM
    JMP SaveScreenLoop

SaveGameStuff:
    JSR SaveScreenTitleTextPosition
    LDA #$08
    JSR DrawZ_MenuString
    JSR TurnMenuScreenOn_ClearOAM
    JSR SaveScreenLoop
    LDA #0
    STA weasels
    RTS

SaveScreenLoop:
    JSR ClearOAM
    JSR DrawSaveScreenCursor
    JSR DrawSaveScreenSprites
    JSR SaveScreenFrame
    LDA joy_b
    BNE @B_Pressed       ; check to see if A or B have been pressed
    LDA joy_a
    BNE @A_Pressed       ; if neither pressed.. see if the cursor has been moved
    LDA joy              ; get joy
    CMP #$30
    BEQ @Select_Pressed
    AND #$0C             ; isolate up/downbuttons
    CMP joy_prevdir      ; compare to previous buttons to see if button state has changed
    BEQ SaveScreenLoop   ; if no change.. do nothing, and continue loop

    STA joy_prevdir      ; otherwise, record changes

    CMP #0               ; then check to see if buttons have been pressed or not
    BEQ SaveScreenLoop   ; if not.. do thing, and continue loop

    CMP #$08             ; if up was pressed
    BEQ @Previous

   @Next:
    INC cursor
    LDA cursor           ; if Up pressed, increase amount
    CMP #3
    BNE @MoveDone        ; if not, jump ahead to @MoveDone
    LDA #0               ; if yes, wrap limit to 1
    JMP @MoveDone        ;

    @Previous:           ; otherwise, it was down
    DEC cursor
    LDA cursor
    CMP #$FF
    BNE @MoveDone        ; if it hasn't gone below 0, that's all -- continue loop
    LDA cursor_max       ; otherwise (below 0), wrap to max

   @MoveDone:             ; code reaches here when A is to be the new amount to buy
    STA cursor
    JMP SaveScreenLoop   ; and continue loop

   @B_Pressed:            ; if B pressed....
    LDA #0
    STA $5113            ; swap battery-backed PRG RAM into $6000 page
    SEC                  ; set C to tell the title screen we didn't load a game
    RTS                  ;

   @A_Pressed:            ; if A pressed...
    LDA cursor
    CMP #02
    BEQ @ThirdSaveSlot
    CMP #01
    BEQ @SecondSaveSlot
    LDA weasels
    BEQ :+
    JSR SaveFirstSlot
    JMP GameSaved
  : JMP LoadFirstSlot

   @ThirdSaveSlot:
    LDA weasels
    BEQ :+
    JSR SaveThirdSlot
    JMP GameSaved
  : JMP LoadThirdSlot

   @SecondSaveSlot:
    LDA weasels
    BEQ :+
    JSR SaveSecondSlot
    JMP GameSaved
  : JMP LoadSecondSlot

   @Select_Pressed:
    LDA #02
    STA dest_y
    LDA #02 ; 10
    STA dest_x
    LDA #01
    STA menustall
    LDA #10
    JSR DrawZ_MenuString
    JSR ConfirmDelete
    BCS JumpSaveScreen ; if B pressed, redraw screen

    LDA cursor
    CMP #02
    BEQ @DeleteThirdSaveSlot
    CMP #01
    BEQ @DeleteSecondSaveSlot
    JMP DeleteFirstSave

   @DeleteThirdSaveSlot:
    JMP DeleteThirdSave

   @DeleteSecondSaveSlot:
    JMP DeleteSecondSave

JumpSaveScreen:
    JMP SaveScreen

ConfirmDelete:
    JSR SaveScreenFrame
    LDA joy_a
    BNE @DoDelete
    LDA joy_b
    BEQ ConfirmDelete  ;  if both are zero, keep looping.  Otherwise...
    SEC
    RTS

   @DoDelete:
    CLC
    RTS


GameSaved:
    LDA #$56
    STA music_track
    STA SaveGameMusic
    LDY cursor
    LDA SavedTextYLUT, Y
    STA dest_y
    LDA #04
    STA dest_x
    LDA #01
    STA menustall
    LDA #09
    JSR DrawZ_MenuString
    JSR DrawSaveScreenNames
    JMP SaveScreenLoop

SavedTextYLUT:
  .byte $09,$11,$19


SaveOverworldInfo:
    LDX #0            ; zero X for upcoming loop
    LDA ow_scroll_x           ; copy over OW information
    STA unsram_ow_scroll_x
    LDA ow_scroll_y
    STA unsram_ow_scroll_y
    LDA vehicle
    STA unsram_vehicle
    RTS

SaveFirstSlot:
    JSR SaveOverworldInfo

  @CopyLoop:
      LDA unsram       , X    ; copy $400 bytes from "unsram" to sram
      STA   sram       , X
      LDA unsram + $100, X
      STA   sram + $100, X
      LDA unsram + $200, X
      STA   sram + $200, X
      LDA unsram + $300, X
      STA   sram + $300, X
      INX
      BNE @CopyLoop           ; loop until X expires ($100 iterations)

    LDA #$55                  ; set assertion bytes
    STA sram_assert_55        ;  if assertion bytes are ever different values
    LDA #$AA                  ;  the game knows SRAM has been corrupted
    STA sram_assert_AA        ;   like due to battery failure or something
    LDA #$00
    STA sram_checksum         ; clear the checksum byte so that it will not interfere with checksum calculations
    LDX #$00                  ; clear X (loop counter)
    CLC                       ; and clear carry so it isn't included in checksum

  @ChecksumLoop:
      ADC sram       , X    ; sum every byte in SRAM
      ADC sram + $100, X    ;  note that carry is not cleared between additions
      ADC sram + $200, X
      ADC sram + $300, X
      INX
      BNE @ChecksumLoop     ; loop until X expires ($100 iterations)
                      ; after loop, A is now what the checksum computes to
    EOR #$FF          ;  to force it to compute to FF, invert the value
    STA sram_checksum ;  and write it to the checksum byte.  Checksum calculations will now result in FF
    RTS


SaveSecondSlot:
    JSR SaveOverworldInfo

  @CopyLoop:
      LDA unsram       , X    ; copy $400 bytes from "unsram" to sram
      STA   sram2       , X
      LDA unsram + $100, X
      STA   sram2 + $100, X
      LDA unsram + $200, X
      STA   sram2 + $200, X
      LDA unsram + $300, X
      STA   sram2 + $300, X
      INX
      BNE @CopyLoop           ; loop until X expires ($100 iterations)

    LDA #$55                  ; set assertion bytes
    STA sram2_assert_55       ;  if assertion bytes are ever different values
    LDA #$AA                  ;  the game knows SRAM has been corrupted
    STA sram2_assert_AA       ;   like due to battery failure or something
    LDA #$00
    STA sram2_checksum        ; clear the checksum byte so that it will not interfere with checksum calculations
    LDX #$00                  ; clear X (loop counter)
    CLC                       ; and clear carry so it isn't included in checksum

  @ChecksumLoop:
      ADC sram2       , X    ; sum every byte in SRAM
      ADC sram2 + $100, X    ;  note that carry is not cleared between additions
      ADC sram2 + $200, X
      ADC sram2 + $300, X
      INX
      BNE @ChecksumLoop     ; loop until X expires ($100 iterations)

                       ; after loop, A is now what the checksum computes to
    EOR #$FF           ;  to force it to compute to FF, invert the value
    STA sram2_checksum ;  and write it to the checksum byte.  Checksum calculations will now result in FF
    RTS

    SaveThirdSlot:
    JSR SaveOverworldInfo

  @CopyLoop:
      LDA unsram       , X    ; copy $400 bytes from "unsram" to sram
      STA   sram3       , X
      LDA unsram + $100, X
      STA   sram3 + $100, X
      LDA unsram + $200, X
      STA   sram3 + $200, X
      LDA unsram + $300, X
      STA   sram3 + $300, X
      INX
      BNE @CopyLoop           ; loop until X expires ($100 iterations)

    LDA #$55                  ; set assertion bytes
    STA sram3_assert_55       ;  if assertion bytes are ever different values
    LDA #$AA                  ;  the game knows SRAM has been corrupted
    STA sram3_assert_AA       ;   like due to battery failure or something
    LDA #$00
    STA sram3_checksum        ; clear the checksum byte so that it will not interfere with checksum calculations
    LDX #$00                  ; clear X (loop counter)
    CLC                       ; and clear carry so it isn't included in checksum

  @ChecksumLoop:
      ADC sram3       , X    ; sum every byte in SRAM
      ADC sram3 + $100, X    ;  note that carry is not cleared between additions
      ADC sram3 + $200, X
      ADC sram3 + $300, X
      INX
      BNE @ChecksumLoop     ; loop until X expires ($100 iterations)

                       ; after loop, A is now what the checksum computes to
    EOR #$FF           ;  to force it to compute to FF, invert the value
    STA sram3_checksum ;  and write it to the checksum byte.  Checksum calculations will now result in FF
    RTS

LoadFirstSlot:
    LDA sram_assert_55              ; check sram assertion values to make sure
    CMP #$55                        ;  sram is not corrupt.  If they are not what are expected...
    BNE UhOhNewGame                    ;  then do a new game.
    LDA sram_assert_AA
    CMP #$AA
    BNE UhOhNewGame

    JSR VerifyChecksum1              ; Then verify checksum to ensure save game integrity
    BCS UhOhNewGame                    ;  if it failed, do a new game

    LDX #$00
    : LDA   sram, X                 ; Copy all of SRAM to unsram
      STA unsram, X
      LDA   sram+$100, X
      STA unsram+$100, X
      LDA   sram+$200, X
      STA unsram+$200, X
      LDA   sram+$300, X
      STA unsram+$300, X
      INX
      BNE :-
    LDA #0
    STA $5113         ; swap battery-backed PRG RAM into $6000 page
    STA MenuHush
    JMP GameLoaded

LoadSecondSlot:
    LDA sram2_assert_55              ; check sram assertion values to make sure
    CMP #$55                        ;  sram is not corrupt.  If they are not what are expected...
    BNE UhOhNewGame                    ;  then do a new game.
    LDA sram2_assert_AA
    CMP #$AA
    BNE UhOhNewGame

    JSR VerifyChecksum2              ; Then verify checksum to ensure save game integrity
    BCS UhOhNewGame                    ;  if it failed, do a new game

    LDX #$00
    : LDA   sram2, X                 ; Copy all of SRAM to unsram
      STA unsram, X
      LDA   sram2+$100, X
      STA unsram+$100, X
      LDA   sram2+$200, X
      STA unsram+$200, X
      LDA   sram2+$300, X
      STA unsram+$300, X
      INX
      BNE :-
    LDA #0
    STA $5113         ; swap battery-backed PRG RAM into $6000 page
    STA MenuHush
    JMP GameLoaded

UhOhNewGame:
    JMP StartNewGame

LoadThirdSlot:
    LDA sram3_assert_55              ; check sram assertion values to make sure
    CMP #$55                        ;  sram is not corrupt.  If they are not what are expected...
    BNE UhOhNewGame                    ;  then do a new game.
    LDA sram3_assert_AA
    CMP #$AA
    BNE UhOhNewGame

    JSR VerifyChecksum3              ; Then verify checksum to ensure save game integrity
    BCS UhOhNewGame                    ;  if it failed, do a new game

    LDX #$00
    : LDA   sram3, X                 ; Copy all of SRAM to unsram
      STA unsram, X
      LDA   sram3+$100, X
      STA unsram+$100, X
      LDA   sram3+$200, X
      STA unsram+$200, X
      LDA   sram3+$300, X
      STA unsram+$300, X
      INX
      BNE :-
    LDA #0
    STA $5113         ; swap battery-backed PRG RAM into $6000 page
    STA MenuHush
    JMP GameLoaded

DeleteFirstSave:
    LDA #0
    TAX
    : STA sram, X
      STA sram+$100, X
      STA sram+$200, X
      STA sram+$300, X
      INX
      BNE :-
      JMP GameDeleted

DeleteSecondSave:
    LDA #0
    TAX
    : STA sram2, X
      STA sram2+$100, X
      STA sram2+$200, X
      STA sram2+$300, X
      INX
      BNE :-
      JMP GameDeleted

DeleteThirdSave:
    LDA #0
    TAX
    : STA sram3, X
      STA sram3+$100, X
      STA sram3+$200, X
      STA sram3+$300, X
      INX
      BNE :-

GameDeleted:
    ;LDA #02
    ;STA dest_y
    LDA #10
    STA dest_x
    LDA #01
    STA menustall
    LDA #11
    JSR DrawZ_MenuString
    JSR DrawSaveScreenNames
    JSR PlayDoorSFX
    JSR WaitForButton
    JMP SaveScreen

WaitForButton:
    JSR SaveScreenFrame
    LDA joy_a
    ORA joy_b
    BEQ WaitForButton
    RTS


SaveScreenFrame:
    JSR WaitForVBlank_L    ; wait for VBlank
    LDA #>oam              ; Do sprite DMA (update the 'real' OAM)
    STA $4014

    LDA soft2000           ; reset scroll and PPU data
    STA $2000
    LDA #0
    STA $2005
    STA $2005

    LDA #BANK_THIS         ; record this bank as the return bank
    STA cur_bank           ; then call the music play routine (keep music playing)
    JSR CallMusicPlay
    JSR ClearButtons
    JMP UpdateJoy          ; update joypad info, then exit



DrawSaveScreenCursor:
    LDX cursor
    LDA @lut, X
    STA spr_y
    LDA #$10
    STA spr_x
    JMP DrawCursor

  @lut:
  .BYTE $38,$78,$B8


SaveScreenTitleTextPosition:
    LDA #02
    STA dest_y
    LDA #11
    STA dest_x
    RTS


DrawSaveScreenNames:
    LDA #0
    STA tmp                    ; tmp = character counter
    TAX                        ; X = string buffer position

   @LoopStart:
    JSR SaveScreenCharPointer
    LDY #ch_name - ch_stats

   @Loop:
    LDA (CharStatsPointer), Y  ; get name byte
    BNE :+
    LDA #$FF                   ; if its 0, replace with a space
  : STA SaveScreenCharBuf, X   ; put in string buffer
    INY
    INX
    CPY #ch_name - ch_stats + 7 ; stop when Y has read the whole name
    BNE @Loop
    
;;  The low 2 bits of each number in the counter are as such:
;;  00 - first character in slot
;;  01 - second character in slot
;;  10 - third character in slot
;;  11 - fourth character in slot
;; so by shifting the bits out, we can tell which character's name is being drawn...
;; and append the necessary control codes!

    LDA tmp
    LSR A
    BCC @FirstOrThirdCharacterInSlot
    
    LSR A     
    BCS @FourthCharacterInSlot
    
   @SecondCharacterInSlot: 
    LDA #05                       ; three single line breaks
    BNE :+
    
   @FourthCharacterInSlot:
    LDA #01                       ; two double line breaks, then one single line break
    STA SaveScreenCharBuf, X
    INX
    STA SaveScreenCharBuf, X
    INX
    LDA #05
    BNE :++
    
   @FirstOrThirdCharacterInSlot:  ; if the character counter = 0, 2, 4, 6, 8, or A, then put 3 spaces
    LDA #$FF
  : STA SaveScreenCharBuf, X
    INX
    STA SaveScreenCharBuf, X
    INX    
  : STA SaveScreenCharBuf, X
    
   @Resume:
    INX      ; inc X until its 10, 10 bytes per character = 120 bytes
    INC tmp
    LDA tmp  ; 12 characters yet?
    CMP #12
    BNE @LoopStart

;; JIGS - I DON'T CARE, IT WORKS. >:(
;; (Edit: I did care and made it better once I got smarter)

;    LDA #$FF ; spaces to put between names on the same line, or just to fill blank space
;    ; because every character has 10 letters in this
;    STA SaveScreenCharBuf+7   ; character 0
;    STA SaveScreenCharBuf+8
;    STA SaveScreenCharBuf+9
;    STA SaveScreenCharBuf+27  ; character 2
;    STA SaveScreenCharBuf+28
;    STA SaveScreenCharBuf+29
;    STA SaveScreenCharBuf+47 ; character 4
;    STA SaveScreenCharBuf+48
;    STA SaveScreenCharBuf+49
;    STA SaveScreenCharBuf+67 ; character 6
;    STA SaveScreenCharBuf+68
;    STA SaveScreenCharBuf+69
;    STA SaveScreenCharBuf+87 ; character 8
;    STA SaveScreenCharBuf+88
;    STA SaveScreenCharBuf+89
;    STA SaveScreenCharBuf+107 ; character A
;    STA SaveScreenCharBuf+108
;    STA SaveScreenCharBuf+109
;
;    LDA #01 ; two lines breaks
;    STA SaveScreenCharBuf+37 ; character 3
;    STA SaveScreenCharBuf+38
;    STA SaveScreenCharBuf+77 ; character 7
;    STA SaveScreenCharBuf+78
;
;    LDA #05 ; one line break
;    STA SaveScreenCharBuf+17 ; character 1
;    STA SaveScreenCharBuf+18 ; character 1
;    STA SaveScreenCharBuf+19 ; character 1
;    STA SaveScreenCharBuf+39 ; character 3
;    STA SaveScreenCharBuf+57 ; character 5
;    STA SaveScreenCharBuf+58 ; character 5
;    STA SaveScreenCharBuf+59 ; character 5
;    STA SaveScreenCharBuf+79 ; character 7
;    STA SaveScreenCharBuf+97 ; character 9
;    STA SaveScreenCharBuf+98 ; character 9
;    STA SaveScreenCharBuf+99 ; character 9

    LDA #0 ; end
    STA SaveScreenCharBuf+117 ; character B

    LDA #13
    STA dest_x
    LDA #06
    STA dest_y
    LDA #<SaveScreenCharBuf
    STA text_ptr
    LDA #>SaveScreenCharBuf
    STA text_ptr+1
    JMP DrawComplexString

;; these values are set in Constants, and point to different save ram slots.
SaveScreenChar_LUT:
.word SaveScreenChar1  ; 0, 1
.word SaveScreenChar2  ; 2, 3
.word SaveScreenChar3  ; 4, 5
.word SaveScreenChar4  ; 6, 7
.word SaveScreenChar5  ; 8, 9
.word SaveScreenChar6  ; A, B
.word SaveScreenChar7  ; C, D
.word SaveScreenChar8  ; E, F
.word SaveScreenChar9  ; 10, 11
.word SaveScreenChar10 ; 12, 13
.word SaveScreenChar11 ; 14, 15
.word SaveScreenChar12 ; 16, 17

SaveScreenCharPointer:
    ASL A
    TAY
    LDA SaveScreenChar_LUT, Y
    STA CharStatsPointer
    LDA SaveScreenChar_LUT+1, Y
    STA CharStatsPointer+1
    RTS

DrawSaveScreenSprites:
    LDA #4
    STA tmp+2               ; loop counter
    LDA cursor
    ASL A
    ASL A
    STA tmp+4               ; cursor * 4: slot 1 = 0, slot 2 = 4, slot 3 = 8
    ASL A
    STA tmp+3               ; cursor * 8: slot 1 = 0, slot 2 = 8, slot 3 = 16

@LoopStart:
    LDA tmp+4                  
    JSR SaveScreenCharPointer
    LDY #ch_basehp - ch_stats
    LDA (CharStatsPointer), Y       ; get base HP for this character
    BEQ @RTS                        ; if its 0, this save slot must be empty, so skip drawing sprites
    LDX tmp+3 
    LDA SaveScreenCharSprite_LUT, X ; tmp+3 just gets the position to draw the sprite on the screen.
    STA spr_x
    INX                             ; increment X
    LDA SaveScreenCharSprite_LUT, X ; instead of doing a +1 to SaveScreenCharSprite_LUT
    STA spr_y
    INX                             ; increment X again and save it
    STX tmp+3

    LDY #ch_sprite - ch_stats
    LDA (CharStatsPointer), Y       ; get sprite from different save slots
    TAY
    LDA lutClassBatSprPalette, Y    ; get sprite palette
    STA tmp+1
    TYA                             ; move sprite ID back to A
    LDX #6
    JSR MultiplyXA                  ; multiply sprite by 6
    STA tmp                         ; tmp and tmp+1 now have the needed values for drawing the sprite
    JSR DrawSimple2x3Sprite
    INC tmp+4                       ; increment the save screen character index counter
    DEC tmp+2                       ; and decrement the loop counter
    BNE @LoopStart

   @RTS:
    RTS

 SaveScreenCharSprite_LUT:
  .byte $56,$27
  .byte $A6,$27
  .byte $56,$40
  .byte $A6,$40 ; positions for character sprites in slot 1 
  
  .byte $56,$67
  .byte $A6,$67
  .byte $56,$80
  .byte $A6,$80 ; slot 2
  
  .byte $56,$A7
  .byte $A6,$A7
  .byte $56,$C0
  .byte $A6,$C0 ; and slot 3





VerifyChecksum1:
    LDA #$00      ; clear A
    LDX #$00      ; and X
    CLC           ; and C!
@Loop:
      ADC sram, X
      ADC sram+$100, X
      ADC sram+$200, X
      ADC sram+$300, X
      INX
      BNE @Loop
      JMP ChecksumSuccessCheck

VerifyChecksum2:
    LDA #$00      ; clear A
    LDX #$00      ; and X
    CLC           ; and C!
@Loop:
      ADC sram2, X
      ADC sram2+$100, X
      ADC sram2+$200, X
      ADC sram2+$300, X
      INX
      BNE @Loop
      JMP ChecksumSuccessCheck

VerifyChecksum3:
    LDA #$00      ; clear A
    LDX #$00      ; and X
    CLC           ; and C!
@Loop:
      ADC sram3, X
      ADC sram3+$100, X
      ADC sram3+$200, X
      ADC sram3+$300, X
      INX
      BNE @Loop

ChecksumSuccessCheck:
    CMP #$FF         ; if result does not equal $FF, the checksum has failed
    BNE ChecksumFail
    CLC
    RTS

ChecksumFail:
    SEC
    RTS








DrawZ_MenuString: ;_Len:
    ASL A                   ; double menu string ID
    TAX                     ; put in X
    LDA lut_ZMenuText, X     ; and load up the pointer into (tmp)
    STA text_ptr
    LDA lut_ZMenuText+1, X
    STA text_ptr+1
    LDA #BANK_THIS
    STA cur_bank          ; set data bank (string to draw is on this bank -- or is in RAM)
    STA ret_bank          ; set return bank (we want it to RTS to this bank when complete)
    JMP DrawComplexString ;  Draw Complex String, then exit!



MenuWaitForBtn_SFX:
    JSR MenuFrame           ; do a frame
    LDA joy_a               ;  check A and B buttons
    ORA joy_b
    BEQ MenuWaitForBtn_SFX  ;  if both are zero, keep looping.  Otherwise...
    LDA #0
    STA joy_a               ; clear both joy_a and joy_b
    STA joy_b
   ; JMP PlaySFX_MenuSel     ; play the MenuSel sound effect, and exit


PlaySFX_MenuSel:
    LDA Options
    AND #SFX_MUTED
    BEQ @Done
    LDA #%00010100
    STA $400C
    LDA #%10001000
    STA $400F
    LDA #%00001010
    STA $400E
   @Done:
    LDA MMC5_tmp ;; JIGS - this routine is used by the options menu only...
    RTS


PlaySFX_MenuMove:
    LDA Options
    AND #SFX_MUTED
    BEQ @Done
    LDA #%00000010
    STA $400C
    LDA #%01000000
    STA $400F
    LDA #$0
    STA $400E
   @Done:
    RTS

MenuFrame:
    JSR WaitForVBlank_L    ; wait for VBlank
    LDA #>oam              ; Do sprite DMA (update the 'real' OAM)
    STA $4014

    LDA soft2000           ; reset scroll and PPU data
    STA $2000
    LDA #0
    STA $2005
    STA $2005

    LDA music_track        ; if no music track is playing...
    BPL :+
      ;LDA #$51             ;  start music track $51  (menu music)
      LDA dlgmusic_backup  ;; JIGS - change to map music
      STA music_track

:   LDA #BANK_THIS         ; record this bank as the return bank
    STA cur_bank           ; then call the music play routine (keep music playing)
    JSR CallMusicPlay
    JSR ClearButtons
    JMP UpdateJoy          ; update joypad info, then exit



;; JIGS - luts go down here:


lut_LowNormalHigh:
.byte $01,$02,$03

lut_OnOff:
.byte $04,$05

lut_ZMenuText:
.word M_OptionsMenu          ; 0
.word OptionNormal           ; 1
.word OptionLow              ; 2
.word OptionHigh             ; 3
.word OptionOff              ; 4
.word OptionOn               ; 5
.word M_SaveSlots            ; 6
.word M_SaveTitle            ; 7
.word M_LoadTitle            ; 8
.word Saved                  ; 9
.word AreYouSure             ; A ; 10
.word Deleted                ; B ; 11
.word SoundTestInstructions  ; C ; 12
.word Zheep                  ; D ; 13
.word PartyGenInstructions   ; E ;
.word BLANK                  ; F ;
.word Song1                  ; 10
.word Song2                  ; 11
.word Song3                  ; 12
.word Song4                  ; 13
.word Song5                  ; 14
.word Song6                  ; 15
.word Song7                  ; 16
.word Song8                  ; 17
.word Song9                  ; 18
.word Song10                 ; 19
.word Song11                 ; 1A
.word Song12                 ; 1B
.word Song13                 ; 1C
.word Song14                 ; 1D
.word Song15                 ; 1E
.word Song16                 ; 1F
.word Song17                 ; 20
.word Song18                 ; 21
.word Song19                 ; 22
.word Song20                 ; 23
.word Song21                 ; 24
.word Song22                 ; 25
.word Song23                 ; 26
.word Song24                 ; 27
.word Song25                 ; 28
.word Song26                 ; 29
.word Song27                 ; 2A
.word Song28                 ; 2B


BLANK:

OptionOn:
.byte $98,$97,$FF,$00

OptionOff:
.byte $98,$8F,$8F,$00

OptionLow:
.byte $95,$98,$A0,$FF,$FF,$FF,$00

OptionNormal:
.byte $97,$98,$9B,$52,$95,$00

OptionHigh:
.byte $91,$92,$90,$91,$FF,$FF,$00

M_OptionsMenu:
.byte $8E,$A1,$99,$8E,$9B,$92,$8E,$97,$8C,$8E,$FF,$90,$8A,$92,$97,$01
.byte $96,$98,$97,$8E,$A2,$FF,$90,$8A,$92,$97,$01
.byte $8E,$97,$8C,$98,$9E,$97,$9D,$8E,$9B,$FF,$9B,$8A,$9D,$8E,$01
.byte $8B,$8A,$9D,$9D,$95,$8E,$FF,$96,$8E,$9C,$9C,$8A,$90,$8E,$FF,$9C,$99,$8E,$8E,$8D,$FF,$FF,$C1,$FF,$FF,$FF,$FF,$C7,$01
.byte $8B,$8A,$9D,$9D,$95,$8E,$FF,$96,$8E,$9C,$9C,$8A,$90,$8E,$FF,$8C,$98,$95,$98,$9B,$FF,$FF,$C1,$FF,$FF,$FF,$FF,$C7,$01
.byte $8A,$9E,$9D,$98,$C2,$9D,$8A,$9B,$90,$8E,$9D,$01
.byte $96,$8E,$97,$9E,$FF,$9C,$8F,$A1,$00


SoundTestInstructions:
.byte $8B,$FF,$C2,$FF,$8E,$BB,$AC,$B7,$05,$8A,$FF,$C2,$FF,$9C,$B7,$A4,$B5,$B7,$F2,$9C,$B7,$B2,$B3,$FF,$96,$B8
.byte $B6,$AC,$A6,$05,$9E,$B3,$F2,$8D,$B2,$BA,$B1,$FF,$C2,$FF,$9C,$A8,$AF,$A8,$A6,$B7,$FF,$9C,$B2
.byte $B1,$AA,$05,$9C,$B7,$A4,$B5,$B7,$FF,$C2,$FF,$91,$B8,$AA,$FF,$A4,$FF,$BA,$A8,$A4,$B6,$A8,$AF,$FF,$E8,$D3,$E8,$00

Zheep:
.byte $A3,$AB,$B3,$C4,$00

M_SaveSlots:
.byte $8F,$92,$95,$8E,$FF,$81,$01,$01,$01,$01,$8F,$92,$95,$8E,$FF,$82,$01,$01,$01,$01,$8F,$92,$95,$8E,$FF,$83,$00

M_SaveTitle:
.byte $95,$98,$8A,$8D,$FF,$FF,$90,$8A,$96,$8E,$00

M_LoadTitle:
.byte $9C,$8A,$9F,$8E,$FF,$FF,$90,$8A,$96,$8E,$00

Saved:
.byte $9C,$8A,$9F,$8E,$8D,$C4,$00

AreYouSure:
.byte $F3,$F4,$7F,$F4,$F3,$F4,$FA,$FF,$8A,$9B,$8E,$FF,$A2,$98,$9E,$FF,$9C,$9E,$9B,$8E,$C5,$FB,$F4,$F3,$F4,$7F,$F4,$F3,$00

Deleted:
.byte $FF,$FF,$8D,$8E,$95,$8E,$9D,$8E,$8D,$C4,$FF,$FF,$FF,$00

PartyGenInstructions:
;.byte $C1,$C7,$FF,$8C,$AF,$3F,$B6,$09,$04,$7A,$7E,$FF,$8C,$41,$B5,$5E,$53,$B5,$00
.byte $C1,$C7,$FF,$8C,$AF,$3F,$B6,$09,$02,$7A,$7E,$FF,$8C,$41,$B5,$5E,$53,$B5,$00


;                      13  12  11  10  0F  0E  0D  0C  0B  0A
;                      19  18  17  16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 -- spaces needed
Song1:
.byte $99,$B5,$A8,$AF,$B8,$A7,$A8,$09,$10,$00                                             ; Prelude
Song2:
.byte $99,$B5,$B2,$AF,$B2,$AA,$B8,$A8,$09,$0F,$00                                         ; Prologue
Song3:
.byte $8E,$B3,$AC,$AF,$B2,$AA,$B8,$A8,$09,$0F,$00                                         ; Epilogue
Song4:
.byte $98,$B9,$A8,$B5,$BA,$B2,$B5,$AF,$A7,$09,$0D,$00                                     ; Overworld
Song5:
.byte $9C,$A4,$AC,$AF,$AC,$B1,$AA,$FF,$9C,$AB,$AC,$B3,$09,$0B,$00                         ; Sailing Ship
Song6:
.byte $8A,$AC,$B5,$B6,$AB,$AC,$B3,$09,$10,$00                                             ; Airship
Song7:
.byte $9D,$B2,$BA,$B1,$09,$13,$00                                                         ; Town
Song8:
.byte $8C,$A4,$B6,$B7,$AF,$A8,$09,$11,$00                                                 ; Castle
Song9:
.byte $8E,$A4,$B5,$B7,$AB,$FF,$8C,$A4,$B9,$A8,$FF,$F2,$FF,$90,$B8,$B5,$AA,$B8,$09,$05,$00 ; Earth Cave / Gurgu
Song10:
.byte $96,$A4,$B7,$B2,$BC,$A4,$09,$11,$00                                                 ; Matoya
Song11:
.byte $96,$A4,$B5,$B6,$AB,$FF,$8C,$A4,$B9,$A8,$FF,$C8,$97,$A8,$BA,$C9,$09,$07,$00         ; Marsh Cave (New)
Song12:
.byte $9D,$A8,$B0,$B3,$AF,$A8,$FF,$B2,$A9,$FF,$8F,$AC,$A8,$B1,$A7,$B6,$09,$07,$00         ; Temple of Fiends
Song13:
.byte $9C,$AE,$BC,$FF,$8C,$A4,$B6,$B7,$AF,$A8,$09,$0C,$00                                 ; Sky Castle
Song14:
.byte $9C,$A8,$A4,$FF,$9C,$AB,$B5,$AC,$B1,$A8,$09,$0C,$00                                 ; Sea Shrine
Song15:
.byte $9C,$AB,$B2,$B3,$09,$13,$00                                                         ; Shop
Song16:
.byte $8B,$A4,$B7,$B7,$AF,$A8,$09,$11,$00                                                 ; Battle
Song17:
.byte $96,$A8,$B1,$B8,$FF,$F2,$FF,$92,$B1,$B1,$FF,$F2,$FF,$96,$A4,$B3,$09,$07,$00         ; Menu / Inn / Map
Song18:
.byte $9C,$AF,$A4,$AC,$B1,$09,$12,$00                                                     ; Slain
Song19:
.byte $8F,$A4,$B1,$A9,$A4,$B5,$A8,$09,$10,$00                                             ; Fanfare
Song20:
.byte $94,$A8,$BC,$FF,$92,$B7,$A8,$B0,$09,$0E,$00                                         ; Key Item
Song21:
.byte $96,$A4,$B5,$B6,$AB,$FF,$8C,$A4,$B9,$A8,$FF,$C8,$98,$AF,$A7,$C9,$09,$07,$00         ; Marsh Cave (Old)
Song22:
.byte $9C,$A4,$B9,$AC,$B1,$AA,$09,$11,$00                                                 ; Saving
Song23:
.byte $91,$A8,$A4,$AF,$AC,$B1,$AA,$FF,$C8,$9E,$B1,$B8,$B6,$A8,$A7,$C9,$09,$07,$00         ; Healing (Unused)
Song24:
.byte $9D,$B5,$A8,$A4,$B6,$B8,$B5,$A8,$FF,$C8,$9E,$B1,$B8,$B6,$A8,$A7,$C9,$09,$06,$00     ; Treasure (Unused)
Song25:
.byte $8F,$AC,$A8,$B1,$A7,$FF,$8B,$A4,$B7,$B7,$AF,$A8,$09,$0B,$00                         ; Fiend Battle
Song26:
.byte $8F,$AC,$A8,$B1,$A7,$FF,$8B,$A4,$B7,$B7,$AF,$A8,$FF,$82,$09,$09,$00                 ; Fiend Battle 2
Song27:
.byte $9B,$B8,$AC,$B1,$A8,$A7,$FF,$8C,$A4,$B6,$B7,$AF,$A8,$09,$0A,$00                     ; Ruined Castle
Song28:
.byte $93,$AC,$AA,$AA,$25,$B6,$FF,$C2,$FF,$8F,$25,$5F,$FF,$8E,$45,$34,$B1,$B7,$B6,$00     ; Jiggers - Feral Elements


lut_CharStatsPtrTable:
  .WORD ch_stats
  .WORD ch_stats+$40
  .WORD ch_stats+$80
  .WORD ch_stats+$C0








.byte "END OF BANK F"
